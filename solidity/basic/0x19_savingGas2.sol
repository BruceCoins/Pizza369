// SPDX-License-Identifier: PDX-3.0
pragma solidity ^0.8.4;

/*
@gas优化2
-   介绍
    通过一些手段或避免一些操作可以大幅优化gas的消耗量。

    1. 合约总是使用32字节的slot来存储状态变量，当开发者在一个slot中存放多个变量时，叫做变量打包。
        -   SSTORE指令的gas成本很高，首次写时，每32字节需要20000 gas，后续每次修改为5000 gas，变量打包可以减少SSTORE指令的使用次数。
        -   变量打包类似内存对齐原则，这里对齐的长度是32字节，将大小加起来等于32字节的变量相邻定义就可以实现。
        -   示例（包含struct成员）
            uint128 a;
            uint128 b; // a和b打包
            uint256 c;
        -   注意1：若定义的变量确实无法打包，应尽量使用256位的类型，因为不是256位的类型会被转换为256位类型进行计算（降低效率），并且不足256位的位置会填充0，也是会收费的。
        -   注意2：内存数据不会打包

    2. 使用合适的数据类型
        -   使用常量constant或不可修改的变量immutable，能够减少gas消耗。
            -   常量与不可变量的区别：常量在编译器确定值，不可变量在部署时确定值
        -   定长比不定长好，前提是能够提前确定数组长度，包含bytesN，而string若是固定的可以用bytsN替代。
            -   string适用于不定长的UTF8序列，bytes适用于不定长的字节序列，其他情况就应该使用定长bytesN，因为后者总是更便宜！
        -   map的gas消耗优于数组。因为map的读写删的gas消耗都是固定的，而数组的gas消耗会跟随长度增长。
            -   仅当数据类型较小时，可以优先使用数组。因为数组元素会进行打包
            -   使用数组时，尽量保持末尾递增，避免数组移位

    3. 内存的使用比存储更廉价
        -   尽量减少对状态变量的修改次数，比如在一个循环中修改状态变量就是一个反例。

    4. 释放存储可以返回gas
        -   释放指的是对状态变量的重置（清除）操作，如delete someArray; 对应汇编指令 SSTORE someVar 0x0;
        -   其他释放操作：selfdestruct
        注意几点：
            -   为了避免退款机制被利用，每笔交易的最高退款额被设定为gas总用量的50%。
            -   返回的gas并不能用来抵偿其他指令的gas消耗，而是在所有指令执行完后结算，这也是一种防御机制。

    5. 减少链上数据
        5.1 使用event存储数据。不需要在链上访问的数据可以存放在事件中达到节省gas的目的。
                -   触发事件的LOG指令的基础费用是375gas，远小于SSTORE指令
                -   通过web3接口监听事件，然后链下存储再查询即可。
        5.2 如果你需要以去中心化的方式保存文件（文档、视频...），应该考虑IPFS（一种分布式的、廉价的文件存储）。
            每个存储在IPFS上的文件将有一个唯一的ID，你可以将其存储在区块链上以供参考，但实际文件将存储在IPFS中。

    6. 减少链上操作
        6.1 bytes替换string：EVM中，string本质上也是bytes，这意味着EVM会把string转换为bytes来处理，所以尽可能使用bytes。
            -   若一定要使用string，尽量将字符串操作（连接等...）放在智能合约之外处理。
        6.2 返回存储值：如果你需要在执行某些功能后返回存储值。按原样返回，不进行转换，让检索数据的链外应用程序做这些工作（从数组中提取某些值等等）。
        6.3 批处理：如果能够将用户的多次合约调用请求进行合并处理（通过动态数组传递参数），这一定能够降低总的gas消耗。

    7. 减少链上数据
        以太坊有4个内存位置，从最便宜到最贵依次是：calldata、栈、内存和存储。如果使用得当，你将节省大量的交易gas。
        7.1 calldata：只适用于输入参数且参数是外部函数的引用数据类型（数组、string或bytes）。
            calldata参数是只读的，如果你有一些需要传递给函数的引用类型，总是考虑使用calldata，因为它是最便宜的。
        7.2 memory：可以用它来存储引用数据类型，它比存储更便宜。当向其他函数传递参数，或在你的函数中声明临时变量时，
            除非你严格需要使用存储，否则应该总是使用内存。
        7.3 storage：是最昂贵的存储位置。存储数据在区块链上持久存在，正如标题所说，应该尽量减少链上数据。

    8. 使用库
        库有两种使用形式：嵌入库和独立部署库
        8.1 嵌入式库：这些库不会被单独部署，而是嵌入到合约中，这意味着你将把库代码与智能合约代码一起部署。因此你不会复用使用任何东西，也不能用嵌入式库节约Gas
        8.2 独立部署库合约：包含public或external函数的库。这些库被部署一次，然后所有导入这些库的智能合约将实际委托给它们调用。这意味着库的代码只被部署一次，
            然后被所有智能合约使用。如果你使用独立部署库，将会节省部署 Gas。

    9. 最小代理（ERC-1167）
        TODO
    10. 优化构造函数
        -   构造函数在部署时执行，所以优化它来优化部署gas消耗。
        -   尽量使用常量而不是immutable变量可以减少gas。
    11. 合约大小
        这是部署成本的一部分。
        -   日志/信息：使revert和assert提示信息尽可能的短。
        -   修改器（modifier）：修改器代码是内联的

    12. 使用error替换string提示。自定义error是solidity 0.8.4 版本才提出来的新特性，下面有示例代码。
        -   与字符串描述相比，自定义error要便宜得多。通过测试，发现自定义error能节省30000多gas

    13. 使用编译器优化代码
        -   优化器试图简化复杂的表达式，从而减少代码大小和执行成本。
        -   solc --optimize --optimize-runs 200 -o dst_path --bin src_code_file
            -   --optimize表示开启字节码优化器，可以减少部署字节码长度
            -   --optimize-runs指定了部署代码的每个操作码在合约的生命周期内被执行的大致频率。次数越小，编译出的字节码越小，但是调用该合约函数可能需要更多gas。
                -   优化内容包括对函数进行形式化或内联，这样可以减少运算量，但会增加字节码长度。
            官方优化器文档：https://docs.soliditylang.org/en/latest/internals/optimizer.html

    14. 避免在合约中动态创建合约，因为一次创建的固定开销是32000gas

    15. 哈希函数的使用，你可以使用智能合约中的几个内置哈希函数：keccak256，sha256和ripemd160。
        -   参数越多，消耗的气体越多。耗气量：ripemd160> sha256> keccak256。因此，如果没有其他目的，建议使用keccak256函数。

    16. 对于逻辑运算符 || 和 &&，是具有短路原则的，如下：
        -   例如有 f(x) || g(y)，若f(x)=true，那么g(y)将不会执行，也不会对g(y)的计算量收费
        -   同理，f(x) && g(y) 若f(x)=false，g(y)也不会执行
        那么此时，若我们能够预判到操作符某一边的表达式更可能（高概率）求得使整个逻辑快速结束的值，就应该将这个表达式放在操作符左边！

    17. Access Sets：当交易提交给 EVM 时，EVM 会创建两个 Set：
            -   touched_addresses : Set[Address]，初始化时包含 tx.origin 和 tx.to
            -   touched_storage_slots : Set[(Address, Bytes32)]，初始化为空
            这两个Set用来作为address的缓存，若合约调用过程中需要访问某个address，对于已存在Set中的address是热访问更便宜，否则就是更贵的冷访问！
            冷访问后address会加入Set，以便后续访问。

    18. topic event：对于使用了indexed字段的event，会使用更多的gas，所以仅在需要过滤时设置indexed！

    19. 进行低级别的call调用时，一定要检查address是否为0x0，因为对于零地址的访问的基础费用是25000 gas，非零地址是9000 gas

    结尾的建议：
        -   开发时，使用emit(gasleft()) 观察优化代码后的gas消耗值！
        -   初始化：由于每次赋值都要消耗gas，所以使用uint x比uint x=0更节省gas。
        -   精确声明函数可见性：仅外部调用的函数应该声明为external而不是public，更节省gas
        -   使用++i 而不是 i++，后者包含的计算步骤更多
        -   警惕循环：依赖时间或数组长度为循环次数的循环需要注意，可能出现随时间或数组长度变化而增加循环次数的漏洞。
            -   应优化代码：尽可能将循环次数固定下来。若无法固定，应该尽量降低循环次数，比如依赖时间长度计算收益的质押合约，可以设置质押有效期。比如设置有效期为一年，一年到期后用户需要提取再质押。


*/

error NotEnoughFunds(uint256 needed, uint256 balance);

contract LearnGasOptimize {
    uint256 needed = 110;
    uint256 balance = 100;

    function judge() external {
        if (balance < needed) {
            // 替换 revert("NotEnoughFunds,needed:110,balance:100")
            revert NotEnoughFunds(needed, balance);
        }
        balance -= needed;
    }
}