Yul语法
==========

语法规则
----------
Yul可以指定由代码、数据、子对象组成“对象”，对象的代码部分总是由一个大括号包裹的块组成，一个**代码块**内，可以使用以下元素：

**没有分号** 每行代码后不需要分号
**注释** 使用``//``和``/* */``来表示。  
**字母** 例如：``0x123``，``22``或``abc``(32各字符以内的字符串)。  
**内置函数调用** 例如：``add(1,mload(2))``  
**变量声明** 例如：``let x = 7``,``let x:= add(y,2)``或``let x``(初始值为0)  
**标识符(变量)** 例如：``add(2,8)``  
**赋值** 例如：``x := add(y,2)``  
**局部变量的作用域所在的代码块** 例如：
```
    {
        let x:= 3 
        {
            let y := add(x,2)
        }
    }
```
**if语句** 例如：
```
    if lt(a,b){ 
        sstore(0, 1) 
    }    
```
**switch语句** 例如:
```
    switch mload(0)
        case 0 { revert() }
        default { mstore(0, 1) }
```
**for循环** 例如：
```
    //相当于 for(i=0; i<10; i++)
    for {let i := 0} lt{i, 10} {i := add(i,1) }
        {
            mstore(i, 7)
        }
```
**函数定义** 例如：
```
    function f(a, b) -> c{
        c := add(a, b)
    }
```

字面量
----------

作为字面量，可以使用。

- 以十进制或十六进制符号表示的整数常数
- ASCII字符串（例如``"abc"``），可能包含十六进制转义``\xNN``和Unicode转义``\uNNN``，其中``N``是十六进制数字。
- 十六进制字符串（例如：``hex"7889"``）。

变量声明
----------

使用``let``关键字来声明变量，变量只能在所定义的``{...}``块内可见。
当编译到EVM时，会创建一个新的堆栈槽，为该变量保留，并在到达块的末端时自动移除。
可以为该变量提供一个初始值，若不提供，默认为零。

变量存储在堆栈中，不直接影响内存或存储。
但可以在内置函数``mstore``,``mload``,``sstore``和``sload``中作为内存或存储位置的指针使用。

当一个变量被引用时，其当前值被复制。
```
    {
        let zero := 0
        let v := calldataload(zero)
        {
            let y := add(sload(v), 1)
            v := y
        } //y在这里被“删除”了
        sstore(v, zreo)
        //v和zero在这里被“删除”
    }
```

如果声明的变量 实际类型 与 默认类型不同时，可使用冒号表示。
接收函数返回的多个值时，也可以在一条语句中声明多个变量。
```
    // 以下代码不会被编译，u32和u256类型尚未实现
    {
        let zero:u32 := 0:u32     //实际需要的是u32类型 
        let v:u256, t:u32 := f()  //接收函数f()返回的不同类型
        let x,y := g()            //接收函数g()返回默认类型
    }
```
根据优化器的设置，编译器可以在变量被最后一次使用后释放堆栈槽，即使它仍然在范围内

赋值
-----------
使用 ``:=``操作符进行赋值，数值数量、类型必须匹配
```
    let v := 0;             // 对变量进行赋值
    v := 2                  // 重新赋值
    let  t := add(v, 2)     // 接收内置函数返回值
    function f() -> a,b{}   // 定义函数f(),返回 a,b
    v,t := f()              // 接收函数f()的多个返回值
    let w:u256, x:u32 := g()// 接收函数g()的多个非默认类型返回值
```

If
-----------
- if 条件句大括号必须有
- 不能定义“else”块
- 需要多种选择条件时，可考虑使用“switch”来代替
```
    if lt(calldatasize(), 4){
        revert(0,0)
    }
```

Switch
-----------
- 可作为 if 语句的扩展版本。
- 出于安全考虑，控制流不会从一个条件延续到下一个条件。
- 使用``default``回退或作为默认情况。如果是判断``bool``类型，则不允许有默认情况。
- 条件的列表没有用大括号括起来，但主题需要大括号(与其他语言不同)。
```
    {
        let x := 0
        switch calldataload(4)
        case 0 {
            x := calldataload(0x24)
        }
        default {
            x := calldataload(0x44)
        }
        sstore(0, div(x,2))
    }
```

循环
-----------
> for 循环
- 由 一个初始部分的头、一个条件、一个迭代部分、一个主体 组成。
- **条件** 必须是一个表达式，其他三个是代码块。
- 若初始化部分在顶层声明了任何变量，这些变量范围将延伸至循环的所有部分。
```
    {
        let x := 0
        for {let i := 0} lt(i, 0x100) {i := add(i, 0x200)}{
            x := add(x, mload(i))
        }
    }
```
> while循环（使用for循环代替）
- 只需将for循环的 初始化、迭代部分 为空即可。
```
    {
        let x := 0
        let i := 0
        for { } lt(i, 0x100) { }{
            x := add(x, mload(i))
            i := add(i, 0x20)
        }
    }
```
> 注意：continue或break语句只能在for循环的主题内使用
```
    for{} true {for {} true {} { break }}
    {
        // break也是合法的，因为它在for循环主体内。
    }
```

函数声明
------------
Yul允许自定义函数。这些不应该与 Solidity 中的函数混淆，因为它们从来不是一个合约的外部接口的一部分，而是独立于 Solidity 函数的命名空间的一部分。  
- 对EVM来说，Yul函数从堆栈中获取参数，结果也放到堆栈中。
- 函数可以定义在任何地方。一个函数中，不能访问该函数之外定义的局部变量。
- 返回多个值时，必须用 ``a,b := f(x)``或``let a, b := f(x)``接收并分配变量。
- ``leave``语句用来退出当前函数，类似其他语言中的``return``功能，**但只能在一个函数内使用，且只是退出函数，没有返回值**。
> 注意：EVM语言中有一个内置函数``return``，它可以退出整个执行环境（内部消息调用），而不仅仅是退出当前yul函数
```
    // 通过平方和乘法实现幂函数
    {
        function power(base, exponent) -> result{
            switch exponent
            case 0 { result := 1 }
            case 1 { result := base }
            default {
                result := power(mul(base, base), div(exponent, 2))
                switch mod(exponent, 2)
                    case 1{ result := mul(base, result) }
            }
        }
    }
```