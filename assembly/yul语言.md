Yul语法
==========

语法规则
----------
Yul可以指定由代码、数据、子对象组成“对象”，对象的代码部分总是由一个大括号包裹的块组成，一个**代码块**内，可以使用以下元素：

**注释** 使用``//``和``/* */``来表示。
**字母** 例如：``0x123``，``22``或``abc``(32各字符以内的字符串)。
**内置函数调用** 例如：``add(1,mload(2))``
**变量声明** 例如：``let x = 7``,``let x:= add(y,2)``或``let x``(初始值为0)
**标识符(变量)** 例如：``add(2,8)``
**赋值** 例如：``x := add(y,2)``
**局部变量的作用域所在的代码块** 例如：
```
    {
        let x:= 3 
        {
            let y := add(x,2)
        }
    }
```
**if语句** 例如：
```
    if lt(a,b){ 
        sstore(0, 1) 
    }    
```
**switch语句** 例如:
```
    switch mload(0)
        case 0 { revert() }
        default { mstore(0, 1) }
```
**for循环** 例如：
```
    for {let i := 0} lt{i, 10} {i := add(i,1) }
        {
            mstore(i, 7)
        }
```
**函数定义** 例如：
```
    function f(a, b) -> c{
        c := add(a, b)
    }
```

字面量
----------

作为字面量，可以使用。

- 以十进制或十六进制符号表示的整数常数
- ASCII字符串（例如``"abc"``），可能包含十六进制转义``\xNN``和Unicode转义``\uNNN``，其中``N``是十六进制数字。
- 十六进制字符串（例如：``hex"7889"``）。

变量声明
----------

使用``let``关键字来声明变量，变量只能在所定义的``{...}``块内可见。
当编译到EVM时，会创建一个新的堆栈槽，为该变量保留，并在到达块的末端时自动移除。
可以为该变量提供一个初始值，若不提供，默认为零。

变量存储在堆栈中，不直接影响内存或存储。
但可以在内置函数``mstore``,``mload``,``sstore``和``sload``中作为内存或存储位置的指针使用。

当一个变量被引用时，其当前值被复制。
```
    {
        let zero := 0
        let v := calldataload(zero)
        {
            let y := add(sload(v), 1)
            v := y
        } //y在这里被“删除”了
        sstore(v, zreo)
        //v和zero在这里被“删除”
    }
```

如果声明的变量 实际类型 与 默认类型不同时，可使用冒号表示。
接收函数返回的多个值时，也可以在一条语句中声明多个变量。
```
    // 以下代码不会被编译，u32和u256类型尚未实现
    {
        let zero:u32 := 0:u32     //实际需要的是u32类型 
        let v:u256, t:u32 := f()  //接收函数f()返回的不同类型
        let x,y := g()            //接收函数g()返回默认类型
    }
```