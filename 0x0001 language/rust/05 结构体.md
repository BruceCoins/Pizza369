## 结构体  
```rust
fn main(){
    //初始化 可修改的 结构体对象
    let mut user1 = User{
        email : String::from("someone@gmail.com"),
        username : String::from("Jack"),
        active: true,
        sign_in_count: 1, 
    };

    // 初始化 第二个 结构体对象，与 user1 只有 username 不同，可如下写
    let mut user2 = User{
        username: String::from("Jerry");
        ..user1
    };

    //获取变量名
    user1.username = String::from("lucy");
    
}

//结构体
struct User{
    active:bool,
    username: String,
    email: String,
    sign_in_count:u64,
}

//参数 与结构体中的字段 一致 时，可以直接写参数名
fn build_user(email:String, username:String) -> User{
    active: true,
    username,
    email,
    sign_in_count: 1,
}

```
### 1、Tuple Struct (元组结构体，字段没有名字只有类型)
```rust
//定义两个 元组结构体
struct Color(i32, i32, i32);
struct Point((i32, i32, i32);

fn main(){
    //初始化
    let black = Color(0,0,0);
    let origin = Point(0,0,0);
}
```
### 2、Unit-Like Struct (无字段的Struct)
```rust
//该结构体 只有名字，没有字段内容
struct AlwaysEqual;

fn main(){
    let subject = AlwaysEqual;
}
``` 
### 3、Derived Traid   
```rust
//引入derive，否则不能正常 print
#[derive(Debug)]

//创建结构体
struct Rectangle{
    width: u32,
    height:u32,
}

fn main(){
    //结构体初始化赋值
    let rect1 = Rectangle{
        width: 20,
        height: 40,
    };

    //使用 :#? 输出内容
    println!("rect1 is {:#?}", rect1);
}
```
### 4、Struct 方法(关键字 impl、self)
```rust
#[derive(debug)]
struct Rectangle{
    width: u32,
    height:u32,
}

//关键字：impl， 参数 self
impl Rectangle{

    // 方法1：第一个参数 &self，实际调用时第一个参数不传值
    //      &self -> self: &Self 类型 
   fn area(&self) -> 32{
        self.width * self.height
    }

    // 方法2：多参数时，第一参数 &self
    fn can_hold(&self, other:&Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    //方法3：第一个参数不是 &self 叫做关联函数，此处返回值首字母大写
    fn square(size: u32) -> Self {
        Self{
            width: size,
            height:size,
        }
    }
}

fn main(){
    //调用关联函数：
    let rec = Rectangle::square(3);

    //初始化 构造函数
    let rect1 = Rectangle{
        width: 10,
        height: 20,
    };

    let rect2 = Rectangle{
        width: 10,
        height: 40,
    };

    //输出结构体
    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));    //第一个参数不传值调用
    println!("Can rect1 hold rect2? {}", Rectangle::can_hold(&rect1, &rect2)); //传参调用
}
```
### 5、方法调用 与 所有权  

```rust
//使结构体实现了Copy Trait，具有 复制、克隆属性
#[derive(Copy,Clone)]

//结构体
struct Rectangle{
    width: u32,
    height: u32,
}

//方法：
impl Rectangle{
    //方法1：&self 不可变引用
    fn area(&self) -> u32{
        self.width * self*height
    }

    //方法2：第一个参数为 可变的引用，
    fn set_width(&mut self, width:u32){
        self.width = width;
    }

    //方法3：参数没有 & ，那么 self 会获得所有权
    fn max(self, other:Self) -> Self{
        let m = self.width.max(other.width);
        let n = self.height.max(other.height);
        Rectangle{
            width:m,
            height:n,
        }
    }

    //方法4：&mut可变的引用
    //     max()方法会获得所有权，参数中self是可变的引用，没法获得所有权
    //     引入 #[derive(Copy, Clone)]，使 max() 参数 self 不再要求所有权，
    //     使max()参数self进行复制，而不是获得所有权 Rectangle::max(*self, other);
    fn set_to_max(&mut self, other:Rectangle){
        *self = self.max(other);     //错误！！解决办法：添加 #[derive(Copy,Clone)]
    }
}

fn main(){
    let rect1 = Rectangle{
        width: 0,
        height: 0
    };
    let other_rect = Rectangle{
        width: 1,
        height: 1
    };
    
    let other_rect = rect.max(other_rect); //max方法会获得 rect和other_rect所有权
    println!("{}", rect.area());   //错误！！rect所有权已经转移，无法再调用area()方法
}
```
## **Copy trait 的作用**    

结构体可以通过 #[derive(Copy, Clone)] 自动实现   
- Copy trait 是针对整个结构体/枚举类型实现的
- 不是针对 impl 块中的某个具体方法
- 要么整个类型实现 Copy，要么不实现

以下是不同类型参数在实现 `Copy` trait 前后的行为变化（值类型）：

| 参数类型      | 实现 Copy 前        | 实现 Copy 后               |
|--------------|--------------------|----------------------------|
| `&T`         | 借用，不获取所有权    | 借用，不获取所有权（无变化）    |
| `&mut T`     | 可变借用，不获取所有权 | 可变借用，不获取所有权（无变化）|
| `T`          | 移动所有权           | 复制值                      |
| `&Rectangle` | 借用 Rectangle      | 借用 Rectangle（无变化）     |
| `Rectangle`  | 移动 Rectangle      | 复制 Rectangle             |

这个表格说明了：
- 引用类型的参数行为不会因 `Copy` trait 而改变
- 值类型的参数会从移动语义变为复制语义
- `Copy` trait 主要影响值的传递方式，而不是方法的调用方式
