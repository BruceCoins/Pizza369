## Enum 枚举
```rust
//枚举
fn main() {
    println!("Hello, world!");

    let x = value_in_coin(Coin::BTC);
    let y = value_in_coin(Coin::USDT(UsState::Alabama));
    println!("x = {}, y = {}",x,y);

    match_method();
}

//定义枚举(驼峰命名法)
enum IpAddrKind {
    V4,
    V6,
}
fn enum_demo() { 
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
} 
```
### 【1】-------enum + struct---------  
```rust
//定义结构体,包含枚举
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
// 
fn enum_demo2(){
    let home = IpAddr{
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    
    let loopback = IpAddr{
        kind: IpAddrKind::V6,
        address: String::from("192.168.1.1"),
    };
}
```
### 【2】-----------简化 上述代码------------  
```rust
//定义枚举，规定了枚举值类型
enum IpAddr2{
    V4(u8, u8, u8, u8),
    V6(String),
}
//创建枚举值
fn enum_demo3(){
    let home = IpAddr2::V4(127,0,0,1);
    let loopback = IpAddr2::V6(String::from("192.168.1.1"));
}
```
### 【3】------------枚举值多类型、方法调用------------
```rust
//定义枚举
enum Message{
    Quit,
    Move{x: i32, y: i32},
    Write(String),
    ChangeColor(i32, i32, i32),
} 
//定义枚举方法，与Struct类似
impl Message{
    fn call(&self){
        //方法定义
    }
}
```
### 【4】------------Option枚举 ------------
```rust
//Option来自标准库，可以直接使用Some和None
// Option<T> 和 T 是不同的类型
// enum Option<T>{
//     Some(T),
//     None,
//}

//创建Option,直接使用Some和None
fn enum_demo4(){ 
    let some_number = Some(8);
    let some_thing = Some("hello");
    let absent_number: Option<i32> = None;
}
```
### 【5】----------Match 匹配：必须穷尽所有情况------------
```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    BTC,
    ETH,
    USDT(UsState),
}

fn value_in_coin(coin: Coin) -> String{
    match coin{
        Coin::BTC => String::from("1"),
        Coin::ETH => {
            println!("ETH");
            String::from("3")
        },
        Coin::USDT(state) => {
            println!("UsState is {:?}",state);
            String::from("5")
        },
    }
}
```
### 【6】-----------match + option--------------
```rust
fn match_option(x:Option<i32>) -> Option<i32>{
    match x{
        Some(i) => Some(i+1),
        None => None,
    }
}
fn match_method(){
    let five = Some(5);
    let six = match_option(five);
    let none = match_option(None);
    println!("six = {:?}, none = {:?}",six,none);  //Some(6), None
}
```
### 【7】**所有权** 
```rust
let opt = Some(String::from("Hello World"));

//如果要是 Some(s) 起作用，应该使用引用 match &opt{}
match opt{
  // 参数为 _ 时，说明没有使用 opt ，所有权未移动， 结尾输出opt可以执行  
  //Some(_) => println!("Some is {}", s),

  // 参数为 s 时，opt 的 Some(T) 所有权进行了移动，结尾输出opt将报错
    Some(s) => println!("Some is {}", s);
  
    None => println!("None"),
};

println!("opt = {:?}", opt);
```
### 【8】-------------if let-----------------
```rust
fn if_let() {
    let config_max = Some(3u8);
    
    //只是判断一两种情况时使用
    if let Some(max) = config_max {
        println!("if_let the max is {}",max);
    }else{
        println!("if_let the max is none");
    }

    //需要穷尽所有情况
    match config_max{
        Some(max) => println!("match The max is {}",max),
        None => (),
    }
}
  ```  