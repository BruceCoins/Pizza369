## 以太坊  
- 以太坊出块时间间隔 **17 秒**  
- 以太坊账户以键值对形式存储，key和value都是 **256位** 的哈希值，key是账户地址，value是账户余额  
- 内存读的长度被限制为 **256位** ，写的长度为 **8位 或 256位**  
- EVM 执行时，每个指令执行时间 **0.00000001秒**
- EVM 基于栈，栈最大 **1024个元素** ，每个元素长 **256位**  
- EVM 多有指令集都是针对 **256 位的字**
- 合约进行消息调用，调用深度被限制为 **1024** ，因此对于更复杂的操作，应使用 **循环而不是递归**  

## Gas   
- ``constant``（常量）和``immutable``（不变量），让不应该变的变量保持不变。这样的做法能在 **节省gas** 的同时提升合约的安全性
- ``event``（事件）是EVM上比较经济的存储数据的方式，每个大概消耗 **2,000 gas**；相比之下，链上存储一个新变量至少需要 **20,000 gas**

## 函数选择器、函数签名  


### 1、数据类型  
- int 和 uint 长度为 **8到256位** ，int 为带符号的，uint 为无符号的  
- 地址类型存储一个 **20字节** 的地址，类型为 **address**
- 引用类型（数组、结构体），在使用时必须声明数据存储位置（storage、memory、calldata）
  - **storage**：合约里的状态变量默认都是storage，**存储在链上**。
  - **memory**：函数里的参数和临时变量一般用memory，**存储在内存中，不上链**。尤其是如果返回数据类型是变长的情况下，必须加memory修饰，例如：string, bytes, array和自定义结构。
  - **calldata**：和memory类似，**存储在内存中，不上链**。与memory的不同点在于calldata变量不能修改（immutable），一般用于函数的参数。
  
### 2、时间单位  
- seconds、minutes、hours、days、weeks

### 3、引用类型  
- bytes 是数组，但声明时不加 **[]** ,可以使用 bytes 或 byte1[] 来声明单字节数组，**bytes 比 bytes1[] 省gas**
  - storage 数组 **可以** 通过 push() 和 pop() 方法来调节长度
  - memory  数组 **不能** 使用 push() 和 pop() 方法来调节长度

### 4、映射（mapping）类型  
- 形式： mapping(key => value)
- 规则1：**key**  只能是 Solidity 内置值类型 uint、address等，不能自定义（如结构体）。**value**  可以自定义
- 规则2：存储位置必须是 storage，因此 **可以用在** 合约状态变量、函数中storage变量、库(library)中函数的参数。**不能用于** public函数的参数或返回结果中

### 5、delete 操作符  
``delete a`` 让变量 a 的值回到初始化  
[delete 用法](https://www.cnblogs.com/secbro/p/11266263.html)  

### 6、常数  
- ``constant`` 声明时直接初始化，且不能再修改
```solidity
uint constant UINTNUMBER = 666666; 
```
- ``immutable`` 可以先声明、后在构造函数中初始化，更灵活方便
```solidity
// 先声明，后初始化
address public immutable IMMU_ADDRESS;
uint256 public immutable IMMU_UINT;

// 构造函数
// 在构造函数中初始化，更灵活
constructor(){
  IMMU_ADDRESS = address(this);
  IMMU_UINT = getUint
}

function getUint() public returns(uint256){
  return 6
}
```
- 只有 **数值** 类型可以用 constant、immutable 修饰；**string 和 bytes** 只能使用 constant，不能使用 immutable 

### 7、插入排序  
```solidity
    function insertionSort1(uint[] memory a) public pure returns(uint[] memory){
        for(uint i = 1; i < a.length; i++){
            uint temp = a[i];
            uint j = i - 1;
            while((j >= 0) && (temp < a[j])){
                a[j+1] = a[j];
                j--;
            }
            a[j+1] = temp;
        }
        return(a);
    }
```

### 8、构造函数(contract)、修改器（modifier）  
```solidity
// 构造函数、修饰器
contract Construct_Modifier{

    // 构造函数
    address public addr;

    constructor(address initAddress){
        addr = initAddress;
    }

    //修饰器
    modifier onlyOwner{
        require(msg.sender == addr);
        _;
    }
    function changeOwner(address newAddr) external onlyOwner{
        addr = newAddr;
    }
}
```

### 9、事件(event)、日志  
- 定义：**event EventName** (address **indexed from, address indexed to, uint256 value);  
- 使用：**emit EventName** (from, to, value);
- ``indexed``：为事件（event）**参数**创建一个可搜索的索引，以便更高效地过滤和检索事件。每个事件最多使用 ``3 个``
```solidity
//事件类型
contract EventType{
    //设置 帐号->金额 键值对
    mapping(address => uint256) public _balance;

    // 定义事件  Transfer，记录交易的转账地址、接收地址、交易数量
    event Transfer(address indexed from, address indexed to, uint256 value);

    function _transfer(
        address _from,
        address _to,
        uint256 _value
    ) external {
        _balance[_from] = 10000000;   // 定义交易地址金额数量

        _balance[_from] -= _value;  // 交易地址 转账后剩余金额
        _balance[_to] += _value;    // 接收地址 转账后剩余金额

        // 使用 emit 释放事件
        emit Transfer(_from, _to, _value); 
    } 
}
```  

### 10、继承  
- 类型：
    单继承、多继承、修饰器（modifier）、构造函数（contractor）的继承  
- 规则：
  - 使用 ``this`` 关键字，contract A is B （即 A 继承 B）  
  - ``virtual``: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。  
  - ``override``：子合约重写了父合约中的函数，需要加上override关键字。
- 子合约调用父合约函数：
  - **（1）** 直接使用 ``父合约.函数名()`` 调用父类的函数。
  - **（2）** **单继承时**，使用 ``super.函数名()``  调用距离最近父类的函数；**多继承时**，会将所有父合约具有相同函数名的都调用一遍。  
   
- **【1】** 单继承：  
```solidity

contract Yeye{

    event Log(string msg);

    // 使用 virtual 修饰，允许子类重写
    function Pip() public virtual{
        emit Log("YeYe");
    } 
}

// 使用 is 来继承父类
contract Baba is Yeye{
    
    event Log2(string msg);

    // 使用 override 修饰，说明是重写了父类的方法
    // 使用 virtual 修饰，允许字类重写父类方法
    function Pip() public virtual override {
        emit Log("Baba");
    }

}
```
- **【2】** 多继承
  - 多继承时，要按辈分从高到低写，不然报错，如：
  ```solidity
  contract Son is Yeye, Baba{}
  ```
  - 多继承时，重写多个父合约方法时， ``override`` 关键字后要加上所有父类名，例:
  ```solidity
  function Pip() public virtual override(Yeye, Baba){
      emit Log("son")
  }
  ```
- **【3】** 修饰器（modifier）的继承
方法同样使用 ``virtual`` 和 ``override`` 两个关键字
```solidity
contract Yeye{

    // 使用 virtual 修饰，允许子类重写本 修饰器
    modifier YeyeModifier virtual{
        require(msg.sender == owner)
        _;
    }
}

// 子类继承父类，
contract Baba is Yeye {

    //可以直接使用父类的修饰器
    function TestFunction() public YeyeModifier(){
  
    }

    //也可以重写父类的修饰器，使用 override 
    function TestFunction2() public override{

    }
}
```
- **【4】** 构造函数（constructor）的继承
需要显式的调用父合约的构造函数。

  - 父合约 的构造函数 **没有参数**
  ```solidity
  //父合约
  contract A{
      address public owner;
      
      constructor(){
          owner = msg.sender;
      }
  }
  //子合约
  contract B is A{
      uint public x;
      // 使用 A() 调用父合约的构造函数
      constructor(uint _x) A(){
          x = _x;
      }
  }
  ```
  -  父合约 的构造函数 **有参数**
  ```solidity
  //父合约
  contract A{
      address public owner;
      uint public x;
      contructor(uint _x){
          owner = msg.sender;
          x = _x;
      }
  }

  //子合约
  contract B is A{
      uint public y;

      //父合约构造函数有一个参数
      //_x 是父合约的构造函数需要的参数
      //_y 是子合约的构造函数需要的参数
      constructor(uint _x, uint _y) A(_x){
          y = _y;
      }
  }
  ```
### 11、抽象合约（abstract）和接口（interface）  
- **【1】** 抽象合约
  - 合约里有至少一个未实现的函数，即没有函数体，必须将该**合约**标记为 ``abstract``。 **且该合约不能被部属**
  - 未实现的**函数**，要用 ``virtual`` 来修饰，以便子类重写。
  ```solidity
  //使用 abstract 修饰合约
  abstract contract Test{
      //使用 virtual 修饰函数，函数没有函数体
      function insertTest(uint256 a) public pure virtual returns(uint256);
  }
  ```
- **【2】** 接口  
规则如下：
  - 不能包含状态变量
  - 不能包含构造函数
  - 不能继承 除接口外 的其他合约
  - 所有接口都必须是 ``external`` 修饰，且没有函数体
  - 继承接口的 非抽象合约 必须实现接口的所有功能

### 12、异常（Error、Require、Assert）  

- **【1】** Error
  ``error`` 是 ``solidity 0.8.4`` 版本新加的内容,方便且高效（省gas）地向用户解释操作失败的原因，同时还可以在抛出异常的同时携带参数。  

（1） 使用 ``error`` 定义  
（2） 使用 ``revert`` 调用  

```solidity
mapping(uint256 => address) _owners;

error TransferNotOwner();

function TransferOwner1(uint256 tokenId,address newOwner ) public{
    if(_owners[tokenId] != newOwner){
          revert TransferNotOwner();
    }
    _owners[tokenId] = newOwner;
}
```

- **【2】** Require
``require`` 命令是``solidity 0.8版本之前``抛出异常的常用方法，格式 ``require(检查条件,“异常描述”)``
```solidity
require(_owners[tokenId] == msg.sender, "Transfer Not Owner");
```

- **【3】** Assert
只抛出异常，没有提示。用法 ``assert(检查条件)``
```solidity
assert(_owner[tokenId] == msg.sender);
```
- Gas 消耗对比  
``error``  方法 gas 消耗：24457 (加入参数后gas消耗：24660)  
``require`` 方法 gas 消耗：24755  
``assert`` 方法 gas 消耗：24473

### 12、库合约（Libary）  
- 【1】关键字 ``libary``，例如创建库合约Strings : libary Strings{}

- 【2】库合约 与 普通合约区别
  - 库合约 **不能** 存在状态变量
  - 库合约 **不能** 继承或被继承
  - 库合约 **不能** 接受以太币
  - 库合约 **不能** 被销毁
     
- 【3】库合约 函数 的可见性
  - 设置为 ``public 或 external`` : 在调用函数时会触发一次delegatecall
  - 设置为 ``internal`` : 不会触发 delegatecall
  - 设置为 ``private`` : 只能 库合约内部调用

- 【4】库合约的调用
  - 方法一：使用 ``useing A for B`` 格式，将库合约 A 附加到类型 B 上，如此 B 类型的变量就可以库合约中的函数。
  
    ```solidity
           //将库合约 Strings 附加到 uint256 类型
           using Strings for uint256;
    
           // 使用 uint256 定义的参数可以直接调用库合约中的函数
           function getString(uint256 _number) public pure returns(string memory ){
                return _number.ToHexString();
           }
    ```
  - 方法二：使用 ``库合约名.函数名()`` 的方式调用
    ```solidity
         function getString(uint256 _number) public pure returns(string memory){

              return Strings.toHexString2(_number);
         }
    ```
### 13、接收ETH 时 receive() 和 fallback() 处理   
- 【1】**receive()** 函数是在合约**收到ETH转账**时被调用的函数。
- **格式**：``receive() external payable( ... )``
- **要求**：
  - 一个合约最多有一个 receive() 函数;
  - 不能使用 ``function`` 关键字，直接使用 ``reveive()``，不能有参数;
  - 必须包含 ``exteral`` 和 ``payable`` ;
```solidity
    event Received(address sender, uint value);
    //reveive()函数
    receive() external payable{
        emit Receive(msg.sender, msg.data);
    }
```

- 【2】**fallback()** 函数会在调用合约**不存在**的函数时被触发
- **格式**：``fallback() external [payable]{ ... }``
- **要求**:
  - ``fallback()``声明时不需要 ``function`` 关键字;
  - 必须由 ``external`` 修饰，一般也会用payable修饰;
  ```solidity
      event FallbackCalled(address sender, uint value, bytes data);
      fallback() external payable{
          emit FallbackCalled(msg.sender, msg.value, msg.data);
      }
  ```
  - 触发fallback() 还是 receive()?
  ```solidity
                   接收ETH
                      |
                 msg.data是空？
                    /  \
                  是    否
                  /      \
        receive()存在?   fallback()
              / \
             是  否
            /     \
      receive()   fallback()
  ```
  
