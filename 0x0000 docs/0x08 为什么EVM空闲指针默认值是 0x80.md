# EVM 的空闲内存指针默认值为什么是 0x80

## EVM 的内存布局分为三个主要区域：

 EVM 的设计者 Gavin Wood 在他的博客中表示，在 EVM 的早期设计中，内存布局是根据 x86 Architecture 的模型设计的。x86 Architecture 的**栈增长方向**是从高地址向低地址，这意味着栈的顶部是高地址。  

- **栈（Addr 0x000 - 0x400）**：这个区域用于存储调用栈、本地变量和函数调用参数。栈从高地址（0x400）向低地址增长。  
- **内存（Addr 0x400 - 0x1000）**：这个区域用于动态内存分配，使用 MLOAD 和 MSTORE 指令。分为三个子区域：  
  -  **空闲内存（Addr 0x80 - 0x400）**：这个区域用于动态内存分配。  
  -  **保留内存（Addr 0x00 - 0x80）**：这个区域保留用于未来使用或存储 EVM 的内部数据结构。  
  -  **静态内存（Addr 0x1000 - ...）**：这个区域用于存储合约代码和数据。  

- **存储（Addr ... - ...）**：这个区域用于存储合约存储变量  

## EVM 的设计者 Gavin Wood 在他的博客中解释了这个问题。  
Gavin Wood 表示，在 EVM 的早期设计中，内存布局是根据 x86 Architecture 的模型设计的。x86 Architecture 的栈增长方向是从高地址向低地址，这意味着栈的顶部是高地址。  

在 EVM 中，栈的大小是固定的，大小是 1024 个字节（0x400）。EVM 的设计者将栈分配在内存的高地址端，以便在需要时可以快速扩展栈。  

- **默认的 mfree 指针值 0x80 是基于以下考虑**：   

**栈的大小**：EVM 的栈大小是 1024 个字节， addr 0x400 是栈的顶部。这意味着栈的底部是 addr 0x000。  
**内存对齐**：EVM 的内存布局是根据 256 字节的块对齐的。因此，addr 0x80 是一个合适的选择，它可以让栈和内存区域之间留出足够的空間。  
**兼容性**：EVM 的设计者希望 EVM 能够在不同的架构上运行，包括 x86、ARM 和其他架构。addr 0x80 是一个相对安全的选择，适用于多种架构。  

总之，mfree 指针的默认值 0x80 是基于 EVM 的栈大小、内存对齐和兼容性考虑的结果，而不是一个任意的选择。  
