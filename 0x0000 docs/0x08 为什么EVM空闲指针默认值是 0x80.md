# EVM 的空闲内存指针默认值为什么是 0x80

## EVM 的内存布局分为三个主要区域：

EVM 的设计者 Gavin Wood 在他的博客中表示，在 EVM 的早期设计中，内存布局是根据 x86 Architecture 的模型设计的。x86 Architecture 的**栈增长方向是从高地址向低地址**，这意味着栈的顶部是高地址。  

另根据以太坊黄皮书，EVM 的内存布局被分为多个区域，包括栈、内存和存储。内存区域进一步分为三个部分：空闲内存区域、动态内存区域和静态内存区域。  

- **栈（Addr 0x000 - 0x400）**：栈的大小是固定的，大小是 1024 个字节（0x400），这个区域用于存储调用栈、本地变量和函数调用参数。栈从高地址（0x400）向低地址增长。
  - **栈帧 (Addr 0x000 - 0x1FF)**：这个区域用于存储当前的调用栈，包括函数调用帧、本地变量和函数调用参数。  
  - **栈溢出保护 (Addr 0x200 - 0x2FF)**：这个区域用于栈溢出保护，以防止栈增长太大导致崩溃。  
  - **保留 (Addr 0x300 - 0x3FF)**：这个区域保留为 будущ用的或存储 EVM 的内部数据结构。
  
- **内存（Addr 0x400 - 0x1000）**：这个区域用于动态内存分配，使用 MLOAD 和 MSTORE 指令。分为三个子区域：  
  -  **保留内存（Addr 0x00 - 0x80）**：这个区域保留用于未来使用或存储 EVM 的内部数据结构。  
  -  **空闲内存（Addr 0x80 - 0x400）**：这个区域用于动态内存分配。空闲内存指针，也称为 `mfree` 指针，用于跟踪指向空闲内存区域的开始处。  
  -  **静态内存（Addr 0x400 - 0x1000）**：这个区域用于存储合约代码和数据。  

- **存储（Addr ... - ...）**：这个区域用于存储合约存储变量  

> [!NOTE]
> 具体的地址和区域边界可能会因 EVM 实现和底层平台架构而异。

## 为什么空闲内存指针(`mfree`)初始值是 0x80？  

**1、 栈对齐**：栈区域大小为 1024 字节（0x400），(Addr 0x400) 是栈的顶部，这意味着栈的底部是 (addr 0x000)，且是 256 字节边界（0x100）对齐的。这样，栈从 0x400 向 0x000 增长。为了确保正确的对齐，mfree 指针应该设置为 256 的倍数。0x80 是一个好的选择，因为它在栈和空闲内存区域之间留出 128 字节的间隙（0x80 - 0x00）。  

**2、 空闲内存大小**：通过将 `mfree` 设置为 0x80，空闲内存区域的大小 efectively 是 128 字节（0x80 - 0x00）。这个大小足够小，以避免浪费内存，但足够大，以容纳大多数动态内存分配。  

**3、 保留内存**： (Addr 0x00) 和 (Addr 0x80) 之间的区域用于未来使用或存储 EVM 的内部数据结构。通过保留这个区域，EVM 确保有足够的空间来存储其内部数据结构而不干扰空闲内存区域。  

**4、 兼容性**：选择 0x80 作为默认的 mfree 值，以确保与不同架构，包括 x86、ARM 和其他架构的兼容性，确保在不同架构上运行。  

总之，mfree 指针被初始化为 0x80，是因为它提供了一个良好的平衡点， stack 对齐、空闲内存大小和保留内存 для EVM 的内部数据结构，同时也确保了与不同架构的兼容性。
 
