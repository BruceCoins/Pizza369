## Rust å­¦ä¹ è®°å½•  
æœ¬æ–‡ä¸»è¦è®°å½• Rust ç‰¹è‰²ç”¨æ³•

### è¯­å¥ã€è¡¨è¾¾å¼  
``è¯­å¥``ï¼šæ‰§è¡Œæ“ä½œæŒ‡ä»¤ï¼Œä¸è¿”å›å€¼  
``è¡¨è¾¾å¼``ï¼šè®¡ç®—å¹¶è¿”å›ä¸€ä¸ªç»“æœ  
```rust
// y={} å¤§æ‹¬å·ä¸­çš„ä¸ºè¡¨è¾¾å¼
// x + 1 æ²¡æœ‰åˆ†å·ï¼Œè‡ªåŠ¨è¿”å›ç»“æœã€‚å¦‚æœåŠ ä¸Šåˆ†å·ï¼Œå¤§æ‹¬å·ä¸­å°±ä¸æ˜¯è¡¨è¾¾å¼äº†
fn main(){
    let y = {
        let x = 3;
        x + 1
    };
    // è¾“å‡ºæ—¶ä½¿ç”¨çš„å ä½ç¬¦ {}
    println!("The value of y is {}",y)  
}
```
### å‡½æ•°è¿”å›å€¼  
- ä½¿ç”¨ ``->``å£°æ˜å‡½æ•°è¿”å›ç±»å‹
- ã€1ã€‘ä½¿ç”¨returnè¿”å›ï¼Œ
- ã€2ã€‘å‡½æ•°æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ï¼Œä¸åŠ åˆ†å·ä¼šè‡ªåŠ¨è¿”å›ç»“æœ  
```rust
fn get_num() -> i32{
    6666
}
```

### å¾ªç¯ loop | while | for    
#### loop å¾ªç¯  
- **â€œbreakâ€**ï¼šåœæ­¢ loop å¾ªç¯  
- **â€œbreak è¡¨è¾¾å¼â€**ï¼šåœæ­¢ loop å¾ªç¯ï¼Œå¹¶è¿”å›è¡¨è¾¾å¼å€¼  
- **â€œcontinueâ€**ï¼šè·³å‡ºæœ¬æ¬¡å¾ªç¯
- ** 'æ ‡ç­¾åï¼šloop{}**ï¼šã€å•å¼•å· + æ ‡ç­¾åã€‘

```rust
//loopç®€å•ä½¿ç”¨
fn loop1(){
    //ä¸åœçš„è¾“å‡º gogogo
    loop{
        println!{"gogogo"};
    }
}

// ã€break è¡¨è¾¾å¼ã€‘çš„ä½¿ç”¨
fn loop2(){
    let mut counter = 0;
    let result = loop{
        counter += 1;
        if counter == 10{
            break counter*2;  //ã€break è¡¨è¾¾å¼ã€‘ï¼šç»“æŸå¾ªç¯ï¼Œè¿”å›è¡¨è¾¾å¼çš„ç»“æœ
        }
    };
    println!("the result is {result}");
}

// 'æ ‡ç­¾å ï¼šloop{} çš„ä½¿ç”¨
fn loop3(){
    let mut count = 0;

    //ç¬¬ä¸€å±‚loopå¾ªç¯ï¼Œå®šä¹‰æ ‡ç­¾ä¸ºã€'counting_upã€‘
    'counting_up:loop{
        println!("count = {count}");  //è¾“å‡ºcount
        let mut remaining = 10;

        //ç¬¬äºŒå±‚loopå¾ªç¯
        loop{
            println!("remaining = {remaining}");
            if remaining == 9{
                break;  //è·³å‡ºå½“å‰å¾ªç¯ï¼Œå³ç¬¬äºŒå±‚å¾ªç¯
            }
            if count == 2{
                break 'counting_up;  //è·³å‡ºã€æ ‡ç­¾åã€‘çš„å¾ªç¯ï¼Œå³ç¬¬ä¸€å±‚å¾ªç¯
            }
            remaining -= 1;
        }
        count += 1;
    }
    println!("End count = {count}");
}
```   
#### forå¾ªç¯  
- **â€œfor å…ƒç´  in é›†åˆâ€**ï¼šå¦‚æœå…ƒç´ æ²¡æœ‰ç”¨åˆ°ï¼Œå¯ä»¥ç”¨ ``"_â€`` ä»£æ›¿
- **"range"**ï¼šå¾ªç¯ç‰¹å®šæ¬¡æ•°
```rust
//å¾ªç¯æ•´ä¸ªæ•°ç»„
fn for_example(){
    let a = [10,20,30,40,50,60];
    for e in a{
        println!("the value is {e}");
    }
}

// å¾ªç¯3æ¬¡ï¼Œæ¯æ¬¡ x éƒ½æ˜¯10
fn for_example2(){
    let a = [10;3];  //å®šä¹‰æ•°ç»„ï¼Œ3ä¸ª10
    let mut sum = 0;
    for x in a{
        println!("x = {x}");
        sum += x;
    }
    print!("sum = {sum}");
}

// éå† [1,5) å³4æ¬¡,åŒæ—¶è¾“å‡º 1ï¼Œ2ï¼Œ3ï¼Œ4 
// rev()æ–¹æ³•ä¸ºå€’åºè¾“å‡ºï¼Œå³ 4ï¼Œ3ï¼Œ2ï¼Œ1
fn for_example3(){
    for number in (1..5).rev(){
        println!({number});
    }
    println!("END!");
}

// å¾ªç¯æ—¶å…ƒç´ ä¸ä½¿ç”¨ï¼Œâ€™_â€˜ ä»£æ›¿å…ƒç´ ï¼Œéå†[1,5)ï¼Œå¾ªç¯4æ¬¡
fn for_example4(){ 
    let mut cc = 1;
    for _ in 1..5{
        println!("cc = {cc}");
        cc += 1;
    }
}

//å¾ªç¯æ—¶å…ƒç´ ä¸ä½¿ç”¨ï¼Œç”¨ â€˜_â€˜ä»£æ›¿ï¼Œåˆ™åªæ˜¯å¾ªç¯æ•°ç»„é•¿åº¦çš„æ¬¡æ•°
fn for_example5(){
    let mut dd = 1;
    let a = [10,20,30,40,50,60];
    //å¾ªç¯6æ¬¡
    for _ in a{
        println!("the shuzu is {dd}");
        dd += 1;
    }
}
```

### æ‰€æœ‰æƒ( Stack | Heap å†…å­˜å®‰å…¨ )   
``stack frame(æ ˆå¸§)``ï¼šå­˜æ”¾å‡½æ•° **å±€éƒ¨å˜é‡ã€å‚æ•°ã€è¿”å›å€¼** çš„å†…å­˜ç©ºé—´ã€‚   
- æ•°æ®å°æ—¶ï¼Œstackæ ˆå†…å­˜ä¸­ç›´æ¥å­˜æ”¾åœ¨æ•°æ®ï¼Œæ•°æ®å¿…é¡»æ‹¥æœ‰å·²çŸ¥çš„å›ºå®šå¤§å°
- æ•°æ®å¤§æ—¶ï¼Œç¼–è¯‘æˆ–è¿è¡Œæ—¶ï¼Œæ•°æ®å¯èƒ½å‘ç”Ÿå˜åŒ–å¿…é¡»æ”¾åœ¨Heapä¸­ã€‚stackæ ˆå†…å­˜ä¸­å­˜æ”¾æŒ‡é’ˆåœ°å€æŒ‡å‘Heapå †å†…å­˜ï¼Œæ•°æ®å®é™…ä½ç½®åœ¨Heapå †å†…å­˜ä¸­ã€‚  

#### ã€1ã€‘æ‹¥æœ‰ Copy strait å±æ€§çš„ç±»å‹ï¼šå¯ä»¥ç›´æ¥èµ‹å€¼ b = aï¼Œè¦æ±‚aã€bæ˜¯å¦‚ä¸‹åŒç±»å‹   
```rust   
    æ‰€æœ‰æ•´å‹ã€boolã€charã€æ‰€æœ‰æµ®ç‚¹å‹ã€Tuple(å…ƒç»„)è¦æ±‚å…¶æ‰€æœ‰å­—æ®µéƒ½æ˜¯å‰é¢çš„ç±»å‹   
```   
  
#### ã€2ã€‘ä½¿ç”¨ Box çš„é›†åˆï¼ˆHeapæ“ä½œï¼‰ï¼šä¸èƒ½ç›´æ¥èµ‹å€¼ b = a æ“ä½œï¼Œå¦åˆ™ a çš„å€¼å°†ä¸å†å¯ç”¨ï¼Œè¦æ±‚aã€bæ˜¯å¦‚ä¸‹åŒç±»å‹    
```rust
    Vecã€Stringã€HashMap...
```    
**Box å†…å­˜é‡Šæ”¾åŸåˆ™**ï¼šå¦‚æœä¸€ä¸ªå˜é‡æ‹¥æœ‰ä¸€ä¸ª box ï¼Œå½“ Rust é‡Šæ”¾è¯¥å˜é‡çš„ stack frame æ—¶ï¼ŒRust åŒæ—¶é‡Šæ”¾è¯¥ box çš„å †å†…å­˜ï¼ˆHeapï¼‰  

- ç§»åŠ¨å †ï¼ˆHeapï¼‰æ•°æ®åŸåˆ™   
``å¦‚æœå˜é‡ x å°†å †ï¼ˆHeapï¼‰æ•°æ®çš„æ‰€æœ‰æƒç§»åŠ¨ç»™å¦ä¸€ä¸ªå˜é‡ yï¼Œé‚£ä¹ˆåœ¨ç§»åŠ¨åï¼Œx å°†ä¸èƒ½åœ¨ä½¿ç”¨``

----------å›ºå®šå¤§å°ï¼Œæ•°æ®å°ï¼Œå­˜æ”¾åœ¨stack ä¸­----------
```rust
fn main(){
    let a = 5;
    let b = a;
    println!("a = {a}, b = {b}");   //æ§åˆ¶å°è¾“å‡º a = 5, b = 5
}
```
----------å›ºå®šé•¿åº¦ï¼Œæ•°æ®å¤ªå¤§ï¼Œä¸ºå‡å°å†…å­˜å ç”¨ï¼Œå¯æ”¾åœ¨Heapå †å†…å­˜ä¸­---------
```rust
fn main(){
    //--------å®šä¹‰ä¸¤ä¸ªè¶…å¤§æ•°ç»„ï¼Œè¦æ±‚éƒ½å¯ä»¥ä½¿ç”¨--------
    //å…·æœ‰1000000å…ƒç´ çš„æ•°ç»„ï¼Œå¦‚æœæˆ¿åœ¨stackä¸­ï¼Œç‰¹åˆ«å å†…å­˜
    let a = [0;1000000];

    //é—®é¢˜ï¼šèµ‹å€¼ç»™båï¼Œåœ¨stackä¸­å¤åˆ¶ä¸€ä¸ªæ•°ç»„ï¼Œå¯¼è‡´å†…å­˜å ç”¨çš„æ›´å¤šäº†
    let b = a;    
    println!("a = {a}, b = {b}");
}
```
------------è§£å†³ï¼šå°†æ•°ç»„æ”¾åˆ° Heap å †ä¸­ï¼Œstack æ”¾æŒ‡é’ˆã€ä¸å †ç›¸å…³ï¼Œæ¶‰åŠåˆ°æ‰€æœ‰æƒé—®é¢˜ã€‘-------------
```rust
fn main(){
    //é€šè¿‡Box::new()å°†æ•°ç»„æ•°æ®æ”¾åˆ°å †ä¸­ï¼Œa2æœ‰stackä¸­å­˜æ”¾æŒ‡é’ˆçš„æ‰€æœ‰æƒ
    let a2 = Box::new([0;1000000]);

    //é—®é¢˜ï¼šå¦‚ä¸‹èµ‹å€¼ï¼Œå°†a2 å­˜æ”¾çš„æŒ‡é’ˆ æ‰€æœ‰æƒ è½¬è®©ç»™ b2ï¼Œa2å¤±å»äº†æŒ‡å‘å †çš„æŒ‡é’ˆï¼Œstacké‡Šæ”¾a2æ•°æ®ï¼Œa2æˆä¸ºæœªå®šä¹‰çŠ¶æ€
    let b2 = a2;   

    //æ‰€ä»¥å½“è¾“å‡º a2 æ—¶æŠ¥é”™ï¼Œb2 æ­£å¸¸ä½¿ç”¨
    println!("a2 = {a2}, b2 = {b2}");
}
```
------------è§£å†³ï¼šä½¿ç”¨close()æ–¹æ³•å…‹éš†å †ï¼ˆHeapï¼‰æ•°æ®------------
```rust
fn main(){
    //String ç±»å‹å †æ“ä½œ
    let a3 = String::from(â€œtestâ€);

    // clone()æ–¹æ³•ï¼Œå°†å †å¤åˆ¶ï¼Œa3_cloneçš„æ ˆé’ˆæŒ‡å‘æ–°çš„å †ï¼Œå³åˆ›å»ºæ–°çš„æ‰€æœ‰æƒ
    let a3_clone = a3.clone();
    let a4 = add_suffix(a3_clone);
    println!("{a3_clone}, originally {a3}");
}
fn add_suffix(mut name:String) -> String{
    name.push_str(" Dr. ");
    name
}
```    
-----------ç›´æ¥â€œå­—ç¬¦ä¸²â€å’ŒString::from("å­—ç¬¦ä¸²åŒºåˆ«")----------   
- **å˜é‡ = â€œå­—ç¬¦ä¸²â€**ï¼šå˜é‡å›ºå®šé•¿åº¦ï¼Œå­˜æ”¾åˆ°stackä¸­
- **å˜é‡ = String::from("å­—ç¬¦ä¸²")**ï¼šä½¿ç”¨Stringå¯¹è±¡ï¼Œæ•°æ®å­˜æ”¾åˆ°Heapå †ä¸­ï¼Œstackå­˜æ”¾æŒ‡é’ˆ  
```rust
fn main(){
    //"å­—ç¬¦ä¸²"å¯ä»¥ç›´æ¥èµ‹ç»™å…¶ä»– å˜é‡
    let b1 = "good rust";
    let b2 = b1;
    println!("b1 = {b1}, b2 = {b2}");

    // String å¯¹è±¡ï¼Œä½¿ç”¨clone()æ–¹æ³•å°†Heapå †æ•°æ®å¤åˆ¶ä¸€ä»½ï¼Œæ–°å˜é‡é€šè¿‡æŒ‡é’ˆæŒ‡å‘å¤åˆ¶åçš„å †
    let mut c1 = String::from("Hello World");
    let c2 = c1.clone();

    // c1è¿›è¡Œä¿®æ”¹ï¼Œæ‰€ä»¥éœ€è¦mutä¿®é¥°
    c1.push_str("-->rust");

    let c3 = c1.clone();
    println!("c1 = {c1}, c2 = {c2}, c3 = {c3}");
}
```
### æ‰€æœ‰æƒ--å¼•ç”¨å’Œå€Ÿç”¨  
#### å¼•ç”¨ï¼šæ˜¯æ²¡æœ‰â€œæ‰€æœ‰æƒâ€çš„æŒ‡é’ˆ  
```rust
// String::from()å®šä¹‰å­—ç¬¦ä¸²ï¼Œå˜é‡ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°ï¼Œéšåè¾“å‡ºå˜é‡ã€‚
fn main(){
    let m1 = String::from("Hello");
    let m2 = String::from("World");

    //è°ƒç”¨å‡½æ•°åï¼Œm1ã€m2æ‰€æœ‰æƒè½¬ç§»ç»™äº†å‚æ•°g1ã€g2ï¼Œstackå†…å­˜é‡Šæ”¾
    //å‡½æ•°æ‰§è¡Œå®Œåï¼Œg1ã€g2çš„stackä¹Ÿå°†è¢«é‡Šæ”¾
    greet(m1, m2);

    // â€™_â€˜ å¼€å¤´ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨æ•…æ„ä¸ä½¿ç”¨çš„å˜é‡ï¼Œé¿å…ç¼–è¯‘é”™è¯¯
    let _s = format!("{}, {}",m1, m2); //æ­¤å¤„è¾“å‡ºå°†æŠ¥é”™ï¼Œå› ä¸ºm1ã€m2å·²ç»è½¬ç§»è¯´æœ‰æƒ
}

fn greet(g1:String, g2:String){
    println!("g1 = {g1}, g2 = {g2}");
}
```
----------é€šè¿‡ **å¼•ç”¨ï¼ˆç¬¦å· & ï¼‰** è§£å†³ å˜é‡ä½œä¸ºå‚æ•°ä¼ é€’å æ‰€æœ‰æƒè½¬ç§» çš„é—®é¢˜-----------
```rust
fn main(){
    let m1 = String::from("Hello");
    let m2 = String::from("rust");

    // è°ƒç”¨å‡½æ•°åï¼Œå°†åˆ›å»ºæŒ‡é’ˆæŒ‡å‘ m1ã€m2æ‰€åœ¨çš„stackï¼Œå†é€šè¿‡m1 m2æŒ‡å‘ Heap
    // å‡½æ•°æ‰§è¡Œç»“æŸåï¼Œä¸¤ä¸ªæŒ‡é’ˆä½¿ç”¨å†…å­˜è¢«é‡Šæ”¾ï¼Œm1ã€m2æ‰€æœ‰æƒä¸å—å½±å“
    greet(&m1, &m2);

    // â€™_sâ€˜ å¼€å¤´ï¼Œå‘Šè¯‰ç¼–è¯‘å™¨æ•…æ„ä¸ä½¿ç”¨çš„å˜é‡ï¼Œé¿å…ç¼–è¯‘é”™è¯¯
    let _s = format("m1 = {}, m2 = {}", m1, m2);
}

//å‡½æ•°å‚æ•°ä¸ºæŒ‡é’ˆï¼Œg1ã€g2è·å¾—çš„ä¸æ˜¯m1ã€m2çš„æ‰€æœ‰æƒï¼Œ
fn greet(g1:&String, g2:&String){
    println!("g1 = {g1}, g2 = {g2}");

    //å°†g1 è½¬æ¢ä¸ºåŸå§‹æŒ‡é’ˆ *const String ç±»å‹ï¼ŒæŒ‡å‘Stringå¯¹è±¡ï¼Œ
    //è·å¾— g1 æ‰€æŒ‡å‘çš„å†…å­˜åœ°å€,å³m1 çš„åœ°å€
    let address_in_g1 = g1 as *const String;
    
    println!("g1 = {g1}");
    println!("g1 æŒ‡å‘çš„åœ°å€ = {:p}", address_in_g1);
    println!("g1 çš„å†…å­˜åœ°å€ = {:p}", &g1);
}
```
#### è§£å¼•ç”¨ã€ç¬¦å· *ã€‘è·å–æ•°æ®ï¼Œå¼•ç”¨ã€ç¬¦å· &ã€‘è·å–å½“å‰å˜é‡çš„æŒ‡é’ˆ(åœ°å€)    
``ç®€å•ç†è§£ï¼šæŒ‡é’ˆå°±æ˜¯å¼•ç”¨ï¼Œè·å–å€¼å°±æ˜¯è§£å¼•ç”¨ã€‚é€šè¿‡Boxå®šä¹‰çš„å˜é‡å°±æ˜¯æŒ‡é’ˆã€‚``  
```
let mut x = Box::new(1);    åœ¨ æ ˆ(Stack) å’Œ å †(Heap) ä¸­çš„å­˜æ”¾

æ ˆ(Stack):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å˜é‡å: x            â”‚ (ç¼–è¯‘æœŸæ¦‚å¿µ)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ æ ˆåœ°å€: 0x7fffabcd   â”‚ (&x è·å–åˆ°çš„åœ°å€)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å€¼: æŒ‡é’ˆ 0x123456    â”‚ (x çš„å®é™…å†…å®¹ï¼ŒæŒ‡å‘å †)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

å †(Heap):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ åœ°å€: 0x123456       â”‚ (x æŒ‡å‘çš„å †åœ°å€)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ å€¼: 1                | (*x è·å–åˆ°çš„å€¼)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

let mut x = Box::new(1);
println!("x çš„å€¼(æŒ‡å‘çš„å †åœ°å€): {:p}", x);     // æ‰“å° x ä¸­å­˜å‚¨çš„æŒ‡é’ˆ
println!("x çš„åœ°å€(æ ˆåœ°å€): {:p}", &x);       // æ‰“å° x å˜é‡åœ¨æ ˆ(stack)ä¸Šçš„åœ°å€
println!("*x çš„å€¼: {}", *x);                 // æ‰“å° x åœ¨å †(Heap)ä¸Šå®é™…çš„å€¼
```

ä¸¾ä¾‹è¯´æ˜ï¼š
```rust
fn test(){
    let mut x = Box::new(1);   //å®šä¹‰å¯å˜æŒ‡é’ˆå˜é‡xï¼Œæ•°æ®å­˜æ”¾åœ¨ Heap ä¸Šï¼Œx åœ¨ stack å­˜æ”¾æŒ‡é’ˆ
    let a = *x;                //é€šè¿‡ *x è·å–æŒ‡é’ˆå¯¹åº”çš„ Heap ä¸Šå­˜æ”¾çš„æ•°æ®
    *x += 1;                   //xä¸ºå¯å˜å˜é‡ï¼ŒåŠ æ³•æ“ä½œ
    println!("a = {a}, x = {x}");

    let r1 = &x;               // xä¸ºæŒ‡é’ˆï¼Œ&xå¯¹xè¿›è¡Œå¼•ç”¨ï¼Œåˆ›å»ºä¸€ä¸ªæŒ‡é’ˆ r1 è·å–xæ ˆåœ°å€ 
    let b = **r1;              // *r1 ç¬¬ä¸€æ¬¡è§£å¼•ç”¨ï¼Œè·å– x çš„æŒ‡é’ˆï¼›**r1ç¬¬äºŒæ¬¡è§£å¼•ç”¨ï¼Œé€šè¿‡xæŒ‡é’ˆè·å–åœ¨ Heapä¸Šçš„å€¼
    println!("ri = {r1}, b = {b}");

    let r2 = &*x;              // *x è§£å¼•ç”¨è·å–xå¯¹åº”çš„ heap å€¼ï¼Œ &*x è·å– è§£å¼•ç”¨å å€¼çš„å¼•ç”¨ï¼Œåˆ›å»ºä¸€ä¸ªä¸å¯å˜é‡æŒ‡å‘Heapå€¼
    let c = *r2;               // æ­¤æ—¶ *r2 è·å–Heapå€¼
    println!("r2 = {r2}, c = {c}");
}


```
#### åˆ«åå’Œå¯å˜æ€§ä¸å¯åŒæ—¶å­˜åœ¨  
``åˆ«å``ï¼šé€šè¿‡ å¼•ç”¨ï¼ˆ&ï¼‰ä½¿å¤šä¸ªä¸åŒçš„å˜é‡è®¿é—®åŒä¸€å†…å­˜æ•°æ®   
``å¯å˜æ€§``ï¼šç”¨ mut ä¿®é¥°å˜é‡ï¼Œæ˜¯å˜é‡å¯ä»¥è¢«ä¿®æ”¹   

**ä¸¥é‡é—®é¢˜ï¼š**   
 - é€šè¿‡**é‡Šæ”¾** åˆ«åæ•°æ®ï¼Œä½¿å¾—å¦ä¸€ä¸ªå˜é‡æŒ‡å‘å·²é‡Šæ”¾çš„å†…å­˜ï¼Œå¯¼è‡´é”™è¯¯
 - é€šè¿‡**ä¿®æ”¹** åˆ«åæ•°æ®ï¼Œä½¿å¾—å¦ä¸€ä¸ªå˜é‡æœŸæœ›çš„è¿è¡Œæ—¶å±æ€§å¤±æ•ˆ
 - é€šè¿‡**åŒæ—¶ä¿®æ”¹** åˆ«åæ•°æ®ï¼Œå¯¼è‡´ä¸å¦ä¸€ä¸ªå˜é‡å‘ç”Ÿæ•°æ®ç«äº‰ï¼Œäº§ç”Ÿä¸å¯é¢„æµ‹çš„è¡Œä¸º
 
**è§„å®šï¼šæŒ‡é’ˆå®‰å…¨æ€§åŸåˆ™ï¼ˆæ•°æ®ä¸åº”åŒæ—¶ â€™è¢«åˆ«åå¼•ç”¨â€˜å’Œ'å…·æœ‰å¯å˜æ€§'ï¼‰**  
- Boxï¼ˆæœ‰â€æ‰€æœ‰æƒâ€œçš„æŒ‡é’ˆï¼‰ï¼šä¸èƒ½åˆ«åã€‚å³ä¸èƒ½å°†ä¸€ä¸ªBoxå˜é‡èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼š**ç§»åŠ¨äº†æ‰€æœ‰æƒ**
```rust
fn main(){
    let x:Box<i32> = Box::new(1);
    let y:Box<i32> = x;        // x æ‰€æœ‰æƒè½¬ç§»åˆ° y  
    println!("x = {}", x);     // è¾“å‡ºæŠ¥é”™
    println!("y = {}", y);
}
```
- å¼•ç”¨ï¼ˆæ— â€æ‰€æœ‰æƒâ€œçš„æŒ‡é’ˆï¼‰ï¼šå¯ä¸´æ—¶åˆ›å»ºåˆ«å
```rust
    let y:Box<i32> = Box::new(1);
    let r1:Box<i32> = &y;    //åˆ›å»ºå¼•ç”¨ï¼Œyçš„æ‰€æœ‰æƒ ä¸è½¬ç§» 
    let r2:Box<i32> = &y;    //åˆ›å»ºå¼•ç”¨ï¼Œyçš„æ‰€æœ‰æƒ ä¸è½¬ç§»
    println!("r1:{r1} , r2:{r2}");
```
#### rusté€šè¿‡â€å€Ÿç”¨æ£€æŸ¥å™¨â€œç¡®ä¿å¼•ç”¨çš„å®‰å…¨æ€§    
- å˜é‡å¯¹å…¶æ•°æ®æœ‰ 3 ç§æƒé™ï¼š  
  - è¯»ï¼ˆRï¼‰: æ•°æ®å¯ä»¥è¢«å¤åˆ¶åˆ°å¦ä¸€ä¸ªä½ç½®  
  - å†™ï¼ˆWï¼‰: æ•°æ®å¯ä»¥è¢«ä¿®æ”¹  
  - æ‹¥æœ‰ï¼ˆOï¼‰: æ•°æ®å¯ä»¥è¢«ç§»åŠ¨æˆ–é‡Šæ”¾  

  
ã€1ã€‘é»˜è®¤æƒ…å†µä¸‹ï¼šå˜é‡å¯¹å…¶æ•°æ®å…·æœ‰ è¯» / æ‹¥æœ‰ çš„æƒé™ï¼ˆR / Oï¼‰  
ã€2ã€‘è¢« mut ä¿®é¥°ï¼Œè¿˜ä¼šå…·æœ‰ å†™ çš„æƒé™ï¼ˆWï¼‰  
 âš ï¸ å¼•ç”¨å¯ä»¥ä¸´æ—¶ç§»é™¤è¿™äº›æƒé™    
 
#### å¯å˜å¼•ç”¨ï¼ˆ&mut xï¼‰æä¾›å¯¹æ•°æ® â€å”¯ä¸€çš„â€œ ä¸” â€éæ‹¥æœ‰çš„ï¼ˆé€šè¿‡&å€Ÿç”¨ï¼Œä¸è½¬è®©æ‰€æœ‰æƒï¼‰â€œ è®¿é—®   
- ä¸å¯å˜å¼•ç”¨ï¼ˆå…±äº«å¼•ç”¨ï¼‰ï¼šåªè¯» ã€let y = &x;ã€‘  
- å¯å˜å¼•ç”¨ï¼ˆç‹¬å å¼•ç”¨ï¼‰ï¼šåœ¨ä¸ç§»åŠ¨æ•°æ®æ‰€æœ‰æƒçš„æƒ…å†µä¸‹ï¼Œä¸´æ—¶æä¾›å¯å˜è®¿é—® ã€let y = &mut x;ã€‘
```rust
// åˆ›å»º mut å¯å˜å˜é‡
let mut v:Vec<i32> = vec![1,2,3];

//---------ä¸å¯å˜å¼•ç”¨ & ----------------------------------------
let y = &v[2];    //ä¸å¯å˜å¼•ç”¨æƒ…å†µä¸‹ï¼Œv å¯¹ v[2] åªæœ‰ è¯» çš„æƒé™ï¼Œå¤±å» å†™ çš„æƒé™
let z = &v[2];    
println!("y = {y}, v[2] = {v[2]} "); //å¯æ­£å¸¸è¾“å‡º

//---------å¯å˜å¼•ç”¨ &mut ------------------------------------------
let num: &mut i32 = &mut v[2];  // v å¯¹ v[2] å¤±å»æ‰€æœ‰(è¯»ã€å†™)è®¿é—®æƒé™
println!("v[2] = {}", v[2]); //é”™è¯¯ï¼v[2]æƒé™å·²å€Ÿå‡º

*num += 1;   //ä¿®æ”¹ v[2] æ•°æ®ï¼Œ3 -> 4ï¼Œ*num å¯ä»¥å¯¹ v[2] æœ‰ (å†™) è®¿é—®æƒé™
println!("ç¬¬ä¸‰ä¸ªæ•°æ˜¯{}",*num);
println!("Vector ç°åœ¨æ˜¯ {:?}", v);
```
**é€šè¿‡ä¸Šè¿°ä»£ç ç†è§£ã€å¯å˜å¼•ç”¨ æä¾›å¯¹æ•°æ® â€å”¯ä¸€çš„â€œ ä¸” â€éæ‹¥æœ‰çš„â€œ è®¿é—®ã€‘**ï¼š
- â€éæ‹¥æœ‰çš„â€œè®¿é—®
```rust
//num åªæ˜¯å€Ÿç”¨ï¼Œæ²¡æœ‰æ‰€æœ‰æƒ
let num: &mut i32 = &mut v[2]; 
```
- â€å”¯ä¸€çš„â€œè®¿é—®ï¼ŒèŒƒå›´åœ¨å¯å˜å¼•ç”¨å­˜åœ¨æœŸé—´ï¼š

ã€1ã€‘éæ³•æ“ä½œï¼šè¿åå”¯ä¸€æ€§    
```rust
let mut v:Vec<i32> = vec![1,2,3];
let num: &mut i32 = &mut v[2];  // å¯å˜å¼•ç”¨
let num2 = &v[2];      // ä¸å¯å˜å¼•ç”¨ ï¼ˆé”™è¯¯ï¼ä¸èƒ½åŒæ—¶å­˜åœ¨ å¯å˜ å’Œ ä¸å¯å˜ å¼•ç”¨ï¼‰
println!("{}", *num2);
```  
ã€2ã€‘éæ³•æ“ä½œï¼šå¤šä¸ªå¯å˜å¼•ç”¨    
```rust
let mut v:Vec<i32> = vec![1,2,3];
let num1: &mut i32 = &mut v[2];
let num2: &mut i32 = &mut v[2];  // é”™è¯¯ï¼ä¸èƒ½æœ‰å¤šä¸ªå¯å˜å¼•ç”¨,åŒä¸€æ—¶é—´åªèƒ½å­˜åœ¨ä¸€ä¸ª
*num1 += 1;
*num2 += 1;
```
- **å¯å˜å¼•ç”¨** ç†è§£çš„å…³é”®ç‚¹ï¼š
```rust
1> æ‰€æœ‰æƒä¸å˜ï¼šv å§‹ç»ˆæ‹¥æœ‰æ‰€æœ‰æƒï¼Œä½†åœ¨å¼•ç”¨å­˜åœ¨æœŸé—´ å®Œå…¨æ— æ³•è®¿é—®ï¼ˆè¯»å†™ï¼‰ è¢«å€Ÿç”¨çš„æ•°æ®
2> å€Ÿç”¨æœŸé—´é™åˆ¶ï¼šå½“ &mut v[2] å­˜åœ¨æ—¶ï¼Œä¸èƒ½æœ‰å…¶ä»–å¼•ç”¨è®¿é—®åŒä¸€æ•°æ®
3> å”¯ä¸€ä¿®æ”¹æƒï¼šnum æ˜¯å”¯ä¸€èƒ½ä¿®æ”¹ v[2] çš„é€”å¾„ï¼Œæ‹¥æœ‰å®Œå…¨è®¿é—®ï¼ˆè¯»å†™ï¼‰æƒé™ 
4> ä¸´æ—¶æ€§ï¼šå¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸç»“æŸåï¼Œé™åˆ¶è§£é™¤ï¼Œvæ¢å¤å¯¹ è¢«å€Ÿç”¨æ•°æ®çš„è®¿é—®ï¼ˆè¯»å†™ï¼‰æƒé™
```
- **ä¸å¯å˜å¼•ç”¨** ç†è§£çš„å…³é”®ç‚¹ï¼š
```rust
1> å…±äº«è¯»å–ï¼šæ‰€æœ‰è€…(v)å’Œå¼•ç”¨è€…(z)éƒ½å¯ä»¥è¯»å– v[2]
2> ç¦æ­¢ä¿®æ”¹ï¼šæ‰€æœ‰è€…å’Œå¼•ç”¨éƒ½ä¸èƒ½ä¿®æ”¹
3> å¤šä¸ªå…è®¸ï¼šå¯ä»¥æœ‰å¤šä¸ª ä¸å¯å˜å¼•ç”¨ åŒæ—¶å­˜åœ¨
```
#### ---------æ‰€æœ‰æƒå¸¸è§é”™è¯¯----------  
- å¦‚æœä¸€ä¸ªå€¼ **ä¸æ‹¥æœ‰å †æ•°æ®**ï¼Œé‚£ä¹ˆå®ƒ**å¯ä»¥**åœ¨ **ä¸ç§»åŠ¨æ‰€æœ‰æƒ** çš„æƒ…å†µä¸‹è¢«å¤åˆ¶
```rust
fn main(){
    let v: Vec<i32> = vec![0,1,2];
    let n_ref: &i32 = &v[0];   //è·å¾—i32ç±»å‹å¼•ç”¨
    let n: i32 = *n_ref;       //i32 ä¸æ‹¥æœ‰å †æ•°æ®ï¼Œå¯ä»¥åœ¨ä¸ç§»åŠ¨çš„æƒ…å†µä¸‹è¢«å¤åˆ¶
                               //i32 å®ç°äº† Copy trait ç±»å‹ï¼Œè§£å¼•ç”¨ä¼šå¤åˆ¶è€Œä¸æ˜¯ç§»åŠ¨æ‰€æœ‰æƒ

    let v: Vec[String] = vec![String::from("Hello")];
    let s_ref: &String = &v[0];  //è·å¾— String ç±»å‹å¼•ç”¨
    let s: String = *s_ref    // æŠ¥é”™ï¼ String æ‹¥æœ‰å¯¹æ•°æ®ï¼Œä¸èƒ½åœ¨ä¸ç§»åŠ¨çš„æƒ…å†µä¸‹è¢«å¤åˆ¶
                              // String æ²¡æœ‰å®ç° Copy trait ç±»å‹ï¼Œè§£å¼•ç”¨ä¼šç§»åŠ¨Stringæ‰€æœ‰æƒ
}
```
ã€1ã€‘ä¸æ‹¥æœ‰å †æ•°æ®çš„ç±»å‹ï¼ˆæ•°æ®å­˜å‚¨åœ¨æ ˆä¸Šæˆ–é™æ€å†…å­˜ä¸­ï¼Œæ— éœ€åŠ¨æ€åˆ†å¸ƒå†…å­˜ï¼‰ï¼š
```rust
1> æ•´æ•°ç±»å‹ï¼š
    æœ‰ç¬¦å·æ•´æ•°ï¼ši8,i16,i32,i64,i128
    æ— ç¬¦å·æ•´æ•°ï¼šu8,u16,u32,u64,u128
    æŒ‡é’ˆå¤§å°æ•´æ•°ï¼šisize,usize

2> æµ®ç‚¹æ•°ç±»å‹ï¼š
    å•ç²¾åº¦ã€åŒç²¾åº¦æµ®ç‚¹æ•°ï¼šf32,f64

3> å¸ƒå°”ç±»å‹ï¼štrue,false

4> å›ºå®šå¤§å°çš„æ•°ç»„ã€å…ƒç»„ï¼š
    let arr:[i32;5] = [1,2,3,4,5]      //æ‰€æœ‰å…ƒç´ æ•°æ®å­˜å‚¨åœ¨æ ˆä¸Š
    let tuple:(i32, bool, char) = (88, true, 'A')    //å­˜å‚¨åœ¨æ ˆä¸Š

5> å¼•ç”¨å’ŒåŸå§‹æŒ‡é’ˆï¼š
    let x = 6;
    let y = &x;  //å¼•ç”¨æœ¬èº«å­˜å‚¨åœ¨æ ˆä¸Šï¼ŒæŒ‡å‘æ ˆä¸Šçš„æ•°æ®
    let ptr: *const i32 = &x //*const è·å–åŸå§‹æŒ‡é’ˆ å­˜å‚¨åœ¨æ ˆä¸Š

6> å‡½æ•°æŒ‡é’ˆ
    fn add(a:i32, b:i32) -> i32{
        a+b;
    }
    let f: fn(i32,i32) -> i32 = add;  //å‡½æ•°æŒ‡é’ˆå­˜å‚¨åœ¨æ ˆä¸Š

7> å­—ç¬¦ä¸²åˆ‡ç‰‡(&str)
    let s: &str = "Hello"; //å­—ç¬¦ä¸²å­—é¢é‡å­˜å‚¨åœ¨äºŒè¿›åˆ¶ä¸­ï¼Œå¼•ç”¨å­˜å‚¨åœ¨æ ˆä¸Š

8> å¤åˆç±»å‹ï¼ˆå¦‚æœæ‰€æœ‰å­—æ®µéƒ½å­˜åœ¨æ ˆä¸Šï¼‰
    struct Point{
        x: i32,
        y: i32,
    }
    let p = Point{ x:10, y:88};   //æ•´ä¸ªç»“æ„ä½“å­˜å‚¨åœ¨æ ˆä¸Š

9> æšä¸¾ç±»å‹ï¼ˆå¦‚æœæ‰€æœ‰å˜ä½“éƒ½åœ¨æ ˆä¸Šï¼‰
    enum Color{
        Red, Green, Blue,
    }
    let color = Color::Red;    //å­˜å‚¨åœ¨æ ˆä¸Š

10> Option å’Œ Result(å¦‚æœåŒ…å«çš„æ•°æ®åœ¨æ ˆä¸Š)
    let opt: Option<i32> = Some(66);        //å­˜å‚¨åœ¨æ ˆä¸Š
    let res: Result<i32, &str> = Ok(66)    //å­˜å‚¨åœ¨æ ˆä¸Š
```

ã€2ã€‘æ‹¥æœ‰å¯¹æ•°æ®çš„ç±»å‹ï¼ˆæ•°æ®å­˜å‚¨éœ€åŠ¨æ€åˆ†å¸ƒå †å†…å­˜ï¼Œå¼•ç”¨å­˜å‚¨åœ¨æ ˆä¸Šï¼‰   
```rust
1> å­—ç¬¦ä¸²ç±»å‹: String(å¯å˜å­—ç¬¦ä¸²)ã€Vec<T>ï¼ˆåŠ¨æ€æ•°ç»„ï¼‰
    let s = String::from("Hello");
    let v = vec![1,2,3];

2> æ™ºèƒ½æŒ‡é’ˆç±»å‹ï¼š
    â— Box<T> ç®€å•çš„å¯¹åˆ†é…æŒ‡é’ˆ
      let x = Box::new(66);

    â— Rc<T> å¼•ç”¨è®¡æ•°æŒ‡é’ˆï¼ˆå•çº¿ç¨‹ï¼‰
    â— Arc<T> åŸå­å¼•ç”¨è®¡æ•°æŒ‡é’ˆï¼ˆå¤šçº¿ç¨‹ï¼‰
    let shared = Re::new(String::from("shared"));

3> å¤æ‚æ•°æ®ç±»å‹ï¼š
    struct Person{
        name: String,            //å †æ•°æ®
        hobbies: Vec<String>,    //å †æ•°æ®
    }
    let person = Person{
        name: String::from("jack"),
        hobbies:vec![String::from("Solidity"),String::from("Rust")]
    };
```
### String Slices(åˆ‡ç‰‡)
- è¯­æ³•ï¼š**[start..end]** è·å–å­—ç¬¦ä¸² [start,end) èŒƒå›´åˆ‡ç‰‡
```rust
let s = String::from("Hello World");   //åˆ›å»ºStringå­—ç¬¦ä¸²
let len = s.len();  //é•¿åº¦11

let x = &s[0..5];  // è·å–ä¸‹æ ‡ 0~4 èŒƒå›´åˆ‡ç‰‡
let x2 = &s[..5];  //ä»0å¼€å§‹æˆªå–ï¼Œå¯çœç•¥
 
let y = &s[6..11];  // è·å–ä¸‹æ ‡ 6~10 èŒƒå›´åˆ‡ç‰‡
let y2 = &s[6..];   // åˆ‡ç‰‡èŒƒå›´åˆ°ç»“å°¾ï¼Œç»“å°¾å¯ç›´æ¥çœç•¥

let z = &[..]    // å°†æ•´ä¸ª String ä½œä¸ºåˆ‡ç‰‡è·å–
```

**å¤„ç†å­—ç¬¦ä¸² åˆ‡ç‰‡**ï¼š
```rust
fn main(){
    let  mut s = String::from("Hello World");
    let word = first_word(&s);
    //s.clear();
    println!("{:?}",word);
}

fn first_word(s: &String) -> &str{    
    let bytes = s.as_bytes();                    //è½¬å­—èŠ‚æ•°ç»„ï¼Œè¿”å› åˆ‡ç‰‡

    //bites().iter()åˆ›å»ºè¿­ä»£å™¨
    //enumerate() ä¸ºè¿­ä»£å™¨æ·»åŠ ç´¢å¼•ï¼Œè¿”å›(ç´¢å¼•,å€¼)çš„å…ƒç»„ 
    for(i, &item) in bytes.iter().enumerate(){

        // b'' è¡¨ç¤ºç©ºæ ¼å­—ç¬¦çš„ ASCII å€¼(32)ï¼Œä¸é€‚ç”¨äºæ±‰å­—æ“ä½œ
        if item == b' '{
            return &s[0..i];
        }
    }
    &s[..]
}
```
**ä¼˜åŒ–**ï¼šå°† first_word å‚æ•° &String æ¢æˆ &str   
- ``&String``: æ˜¯å¯¹Stringç±»å‹çš„å¼•ç”¨ï¼Œåªèƒ½æŒ‡å‘Stringå¯¹è±¡ç±»å‹  
- ``&str``ï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼•ç”¨ï¼ŒStringçš„ä¸€éƒ¨åˆ†ï¼Œå¯ä»¥ç›´æ¥ä¼ é€’å­—é¢å­—ç¬¦ä¸² let s = â€œhello worldâ€  

### ç»“æ„ä½“  
```rust
fn main(){
    //åˆå§‹åŒ– å¯ä¿®æ”¹çš„ ç»“æ„ä½“å¯¹è±¡
    let mut user1 = User{
        email : String::from("someone@gmail.com"),
        username : String::from("Jack"),
        active: true,
        sign_in_count: 1, 
    };

    // åˆå§‹åŒ– ç¬¬äºŒä¸ª ç»“æ„ä½“å¯¹è±¡ï¼Œä¸ user1 åªæœ‰ username ä¸åŒï¼Œå¯å¦‚ä¸‹å†™
    let mut user2 = User{
        username: String::from("Jerry");
        ..user1
    };

    //è·å–å˜é‡å
    user1.username = String::from("lucy");
    
}

//ç»“æ„ä½“
struct User{
    active:bool,
    username: String,
    email: String,
    sign_in_count:u64,
}

//å‚æ•° ä¸ç»“æ„ä½“ä¸­çš„å­—æ®µ ä¸€è‡´ æ—¶ï¼Œå¯ä»¥ç›´æ¥å†™å‚æ•°å
fn build_user(email:String, username:String) -> User{
    active: true,
    username,
    email,
    sign_in_count: 1,
}

```
#### 1ã€Tuple Struct (å…ƒç»„ç»“æ„ä½“ï¼Œå­—æ®µæ²¡æœ‰åå­—åªæœ‰ç±»å‹)
```rust
//å®šä¹‰ä¸¤ä¸ª å…ƒç»„ç»“æ„ä½“
struct Color(i32, i32, i32);
struct Point((i32, i32, i32);

fn main(){
    //åˆå§‹åŒ–
    let black = Color(0,0,0);
    let origin = Point(0,0,0);
}
```
#### 2ã€Unit-Like Struct (æ— å­—æ®µçš„Struct)
```rust
//è¯¥ç»“æ„ä½“ åªæœ‰åå­—ï¼Œæ²¡æœ‰å­—æ®µå†…å®¹
struct AlwaysEqual;

fn main(){
    let subject = AlwaysEqual;
}
``` 
#### 3ã€Derived Traid   
```rust
//å¼•å…¥deriveï¼Œå¦åˆ™ä¸èƒ½æ­£å¸¸ print
#[derive(Debug)]

//åˆ›å»ºç»“æ„ä½“
struct Rectangle{
    width: u32,
    height:u32,
}

fn main(){
    //ç»“æ„ä½“åˆå§‹åŒ–èµ‹å€¼
    let rect1 = Rectangle{
        width: 20,
        height: 40,
    };

    //ä½¿ç”¨ :#? è¾“å‡ºå†…å®¹
    println!("rect1 is {:#?}", rect1);
}
```
#### 4ã€Struct æ–¹æ³•(å…³é”®å­— implã€self)
```rust
#[derive(debug)]
struct Rectangle{
    width: u32,
    height:u32,
}

//å…³é”®å­—ï¼šimplï¼Œ å‚æ•° self
impl Rectangle{

    // æ–¹æ³•1ï¼šç¬¬ä¸€ä¸ªå‚æ•° &selfï¼Œå®é™…è°ƒç”¨æ—¶ç¬¬ä¸€ä¸ªå‚æ•°ä¸ä¼ å€¼
    //      &self -> self: &Self ç±»å‹ 
   fn area(&self) -> 32{
        self.width * self.height
    }

    // æ–¹æ³•2ï¼šå¤šå‚æ•°æ—¶ï¼Œç¬¬ä¸€å‚æ•° &self
    fn can_hold(&self, other:&Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    //æ–¹æ³•3ï¼šç¬¬ä¸€ä¸ªå‚æ•°ä¸æ˜¯ &self å«åšå…³è”å‡½æ•°ï¼Œæ­¤å¤„è¿”å›å€¼é¦–å­—æ¯å¤§å†™
    fn square(size: u32) -> Self {
        Self{
            width: size,
            height:size,
        }
    }
}

fn main(){
    //è°ƒç”¨å…³è”å‡½æ•°ï¼š
    let rec = Rectangle::square(3);

    //åˆå§‹åŒ– æ„é€ å‡½æ•°
    let rect1 = Rectangle{
        width: 10,
        height: 20,
    };

    let rect2 = Rectangle{
        width: 10,
        height: 40,
    };

    //è¾“å‡ºç»“æ„ä½“
    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));    //ç¬¬ä¸€ä¸ªå‚æ•°ä¸ä¼ å€¼è°ƒç”¨
    println!("Can rect1 hold rect2? {}", Rectangle::can_hold(&rect1, &rect2)); //ä¼ å‚è°ƒç”¨
}
```
#### 5ã€æ–¹æ³•è°ƒç”¨ ä¸ æ‰€æœ‰æƒ  

```rust
//ä½¿ç»“æ„ä½“å®ç°äº†Copy Traitï¼Œå…·æœ‰ å¤åˆ¶ã€å…‹éš†å±æ€§
#[derive(Copy,Clone)]

//ç»“æ„ä½“
struct Rectangle{
    width: u32,
    height: u32,
}

//æ–¹æ³•ï¼š
impl Rectangle{
    //æ–¹æ³•1ï¼š&self ä¸å¯å˜å¼•ç”¨
    fn area(&self) -> u32{
        self.width * self*height
    }

    //æ–¹æ³•2ï¼šç¬¬ä¸€ä¸ªå‚æ•°ä¸º å¯å˜çš„å¼•ç”¨ï¼Œ
    fn set_width(&mut self, width:u32){
        self.width = width;
    }

    //æ–¹æ³•3ï¼šå‚æ•°æ²¡æœ‰ & ï¼Œé‚£ä¹ˆ self ä¼šè·å¾—æ‰€æœ‰æƒ
    fn max(self, other:Self) -> Self{
        let m = self.width.max(other.width);
        let n = self.height.max(other.height);
        Rectangle{
            width:m,
            height:n,
        }
    }

    //æ–¹æ³•4ï¼š&mutå¯å˜çš„å¼•ç”¨
    //     max()æ–¹æ³•ä¼šè·å¾—æ‰€æœ‰æƒï¼Œå‚æ•°ä¸­selfæ˜¯å¯å˜çš„å¼•ç”¨ï¼Œæ²¡æ³•è·å¾—æ‰€æœ‰æƒ
    //     å¼•å…¥ #[derive(Copy, Clone)]ï¼Œä½¿ max() å‚æ•° self ä¸å†è¦æ±‚æ‰€æœ‰æƒï¼Œ
    //     ä½¿max()å‚æ•°selfè¿›è¡Œå¤åˆ¶ï¼Œè€Œä¸æ˜¯è·å¾—æ‰€æœ‰æƒ Rectangle::max(*self, other);
    fn set_to_max(&mut self, other:Rectangle){
        *self = self.max(other);     //é”™è¯¯ï¼ï¼è§£å†³åŠæ³•ï¼šæ·»åŠ  #[derive(Copy,Clone)]
    }
}

fn main(){
    let rect1 = Rectangle{
        width: 0,
        height: 0
    };
    let other_rect = Rectangle{
        width: 1,
        height: 1
    };
    
    let other_rect = rect.max(other_rect); //maxæ–¹æ³•ä¼šè·å¾— rectå’Œother_rectæ‰€æœ‰æƒ
    println!("{}", rect.area());   //é”™è¯¯ï¼ï¼rectæ‰€æœ‰æƒå·²ç»è½¬ç§»ï¼Œæ— æ³•å†è°ƒç”¨area()æ–¹æ³•
}
```
**Copy trait çš„ä½œç”¨**    

ç»“æ„ä½“å¯ä»¥é€šè¿‡ #[derive(Copy, Clone)] è‡ªåŠ¨å®ç°   
- Copy trait æ˜¯é’ˆå¯¹æ•´ä¸ªç»“æ„ä½“/æšä¸¾ç±»å‹å®ç°çš„
- ä¸æ˜¯é’ˆå¯¹ impl å—ä¸­çš„æŸä¸ªå…·ä½“æ–¹æ³•
- è¦ä¹ˆæ•´ä¸ªç±»å‹å®ç° Copyï¼Œè¦ä¹ˆä¸å®ç°

ä»¥ä¸‹æ˜¯ä¸åŒç±»å‹å‚æ•°åœ¨å®ç° `Copy` trait å‰åçš„è¡Œä¸ºå˜åŒ–ï¼ˆå€¼ç±»å‹ï¼‰ï¼š

| å‚æ•°ç±»å‹      | å®ç° Copy å‰        | å®ç° Copy å               |
|--------------|--------------------|----------------------------|
| `&T`         | å€Ÿç”¨ï¼Œä¸è·å–æ‰€æœ‰æƒ    | å€Ÿç”¨ï¼Œä¸è·å–æ‰€æœ‰æƒï¼ˆæ— å˜åŒ–ï¼‰    |
| `&mut T`     | å¯å˜å€Ÿç”¨ï¼Œä¸è·å–æ‰€æœ‰æƒ | å¯å˜å€Ÿç”¨ï¼Œä¸è·å–æ‰€æœ‰æƒï¼ˆæ— å˜åŒ–ï¼‰|
| `T`          | ç§»åŠ¨æ‰€æœ‰æƒ           | å¤åˆ¶å€¼                      |
| `&Rectangle` | å€Ÿç”¨ Rectangle      | å€Ÿç”¨ Rectangleï¼ˆæ— å˜åŒ–ï¼‰     |
| `Rectangle`  | ç§»åŠ¨ Rectangle      | å¤åˆ¶ Rectangle             |

è¿™ä¸ªè¡¨æ ¼è¯´æ˜äº†ï¼š
- å¼•ç”¨ç±»å‹çš„å‚æ•°è¡Œä¸ºä¸ä¼šå›  `Copy` trait è€Œæ”¹å˜
- å€¼ç±»å‹çš„å‚æ•°ä¼šä»ç§»åŠ¨è¯­ä¹‰å˜ä¸ºå¤åˆ¶è¯­ä¹‰
- `Copy` trait ä¸»è¦å½±å“å€¼çš„ä¼ é€’æ–¹å¼ï¼Œè€Œä¸æ˜¯æ–¹æ³•çš„è°ƒç”¨æ–¹å¼

  ### Enum æšä¸¾
```rust
//æšä¸¾
fn main() {
    println!("Hello, world!");

    let x = value_in_coin(Coin::BTC);
    let y = value_in_coin(Coin::USDT(UsState::Alabama));
    println!("x = {}, y = {}",x,y);

    match_method();
}

//å®šä¹‰æšä¸¾(é©¼å³°å‘½åæ³•)
enum IpAddrKind {
    V4,
    V6,
}
fn enum_demo() { 
    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
} 
```
- -------enum + struct---------  
```rust
//å®šä¹‰ç»“æ„ä½“,åŒ…å«æšä¸¾
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}
// 
fn enum_demo2(){
    let home = IpAddr{
        kind: IpAddrKind::V4,
        address: String::from("127.0.0.1"),
    };
    
    let loopback = IpAddr{
        kind: IpAddrKind::V6,
        address: String::from("192.168.1.1"),
    };
}
```
- -----------ç®€åŒ– ä¸Šè¿°ä»£ç ------------  
```rust
//å®šä¹‰æšä¸¾ï¼Œè§„å®šäº†æšä¸¾å€¼ç±»å‹
enum IpAddr2{
    V4(u8, u8, u8, u8),
    V6(String),
}
//åˆ›å»ºæšä¸¾å€¼
fn enum_demo3(){
    let home = IpAddr2::V4(127,0,0,1);
    let loopback = IpAddr2::V6(String::from("192.168.1.1"));
}
```
- ------------æšä¸¾å€¼å¤šç±»å‹ã€æ–¹æ³•è°ƒç”¨------------
```rust
//å®šä¹‰æšä¸¾
enum Message{
    Quit,
    Move{x: i32, y: i32},
    Write(String),
    ChangeColor(i32, i32, i32),
} 
//å®šä¹‰æšä¸¾æ–¹æ³•ï¼Œä¸Structç±»ä¼¼
impl Message{
    fn call(&self){
        //æ–¹æ³•å®šä¹‰
    }
}
```
- ------------Optionæšä¸¾ ------------
```rust
//Optionæ¥è‡ªæ ‡å‡†åº“ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨Someå’ŒNone
// Option<T> å’Œ T æ˜¯ä¸åŒçš„ç±»å‹
// enum Option<T>{
//     Some(T),
//     None,
//}

//åˆ›å»ºOption,ç›´æ¥ä½¿ç”¨Someå’ŒNone
fn enum_demo4(){ 
    let some_number = Some(8);
    let some_thing = Some("hello");
    let absent_number: Option<i32> = None;
}
```
- ----------Match åŒ¹é…ï¼šå¿…é¡»ç©·å°½æ‰€æœ‰æƒ…å†µ------------
```rust
#[derive(Debug)]
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    BTC,
    ETH,
    USDT(UsState),
}

fn value_in_coin(coin: Coin) -> String{
    match coin{
        Coin::BTC => String::from("1"),
        Coin::ETH => {
            println!("ETH");
            String::from("3")
        },
        Coin::USDT(state) => {
            println!("UsState is {:?}",state);
            String::from("5")
        },
    }
}
```
- -----------match + option--------------
```rust
fn match_option(x:Option<i32>) -> Option<i32>{
    match x{
        Some(i) => Some(i+1),
        None => None,
    }
}
fn match_method(){
    let five = Some(5);
    let six = match_option(five);
    let none = match_option(None);
    println!("six = {:?}, none = {:?}",six,none);  //Some(6), None
}
```
**æ‰€æœ‰æƒ** 
```rust
let opt = Some(String::from("Hello World"));

//å¦‚æœè¦æ˜¯ Some(s) èµ·ä½œç”¨ï¼Œåº”è¯¥ä½¿ç”¨å¼•ç”¨ match &opt{}
match opt{
  // å‚æ•°ä¸º _ æ—¶ï¼Œè¯´æ˜æ²¡æœ‰ä½¿ç”¨ opt ï¼Œæ‰€æœ‰æƒæœªç§»åŠ¨ï¼Œ ç»“å°¾è¾“å‡ºoptå¯ä»¥æ‰§è¡Œ  
  //Some(_) => println!("Some is {}", s),

  // å‚æ•°ä¸º s æ—¶ï¼Œopt çš„ Some(T) æ‰€æœ‰æƒè¿›è¡Œäº†ç§»åŠ¨ï¼Œç»“å°¾è¾“å‡ºoptå°†æŠ¥é”™
    Some(s) => println!("Some is {}", s);
  
    None => println!("None"),
};

println!("opt = {:?}", opt);


```
- -------------if let-----------------
```rust
fn if_let() {
    let config_max = Some(3u8);
    
    //åªæ˜¯åˆ¤æ–­ä¸€ä¸¤ç§æƒ…å†µæ—¶ä½¿ç”¨
    if let Some(max) = config_max {
        println!("if_let the max is {}",max);
    }else{
        println!("if_let the max is none");
    }

    //éœ€è¦ç©·å°½æ‰€æœ‰æƒ…å†µ
    match config_max{
        Some(max) => println!("match The max is {}",max),
        None => (),
    }
}
  ```  
### Crate å’Œ Package
- **Crate**ï¼š   
  - **binary crate**ï¼šå¯æ‰§è¡Œæ–‡ä»¶,src/main.rs   
  - **library crate**ï¼š åº“æ–‡ä»¶, src/lib.rs    

- **Package (ç”±å¤šä¸ª crates ç»„æˆ)ï¼šCargo.tomlæ–‡ä»¶**
  - å¯æœ‰å¤šä¸ª binary crates
  - æœ€å¤šåªèƒ½æœ‰ä¸€ä¸ª library crate
  - è‡³å°‘æœ‰ä¸€ä¸ª crate

```rust
// å‘½ä»¤è¡Œ
# cargo new project_name         //åˆ›å»º binary é¡¹ç›®ï¼ŒåŒ…å« main.rs
# cargo new project_name --lib   //åˆ›å»º binary é¡¹ç›®ï¼ŒåŒ…å« lib.rs
```
### Model(æ¨¡å—)  
**å£°æ˜æ¨¡å—**ï¼š``` mod garden  ```   
**å¼•ç”¨æ¨¡å—**ï¼š``` use å…³é”®å­— ```  

#### 1ã€åˆ›å»ºé¡¹ç›®(åä¸º package_name)  
- åˆå§‹åŒ–é¡¹ç›®ç»“æ„
```
project_name/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ main.rs          # äºŒè¿›åˆ¶ binary crate çš„å…¥å£æ–‡ä»¶
â”œâ”€â”€ Cargo.toml
â””â”€â”€ Cargo.lock          # ä¾èµ–ç‰ˆæœ¬é”æ–‡ä»¶ï¼ˆè‡ªåŠ¨ç”Ÿæˆï¼‰
```  
- Cargo.tomlæ–‡ä»¶   
```rust  
[package]
name = "package_name"    //package åå­—
version = "0.1.0"        //ç‰ˆæœ¬
edition = "2021"         //rustç‰ˆæœ¬ä¿¡æ¯

[dependencies]           //é¡¹ç›®ä¾èµ–
```  
#### 2ã€model å¼•ç”¨æ–¹å¼  
ã€1ã€‘å†…è”æ¨¡å¼ï¼šåœ¨å¼•ç”¨modelçš„æ–‡ä»¶å†…éƒ¨ç›´æ¥å®šä¹‰  
```rust
//ç›´æ¥åœ¨æ–‡ä»¶ä¸­å®šä¹‰ modelï¼Œæ‰«æåå­—åè¾¹æ˜¯å¦æœ‰{}
mod models{ .. }
```
ã€2ã€‘**æœ€å¸¸ç”¨ï¼ï¼ï¼ï¼**å•ç‹¬åˆ›å»ºmodels.rsæ–‡ä»¶ï¼Œå†å°†modelåˆ—è¡¨æ”¾åˆ°lib.rsä¸­  
- é¡¹ç›®ç»“æ„
```rust
project_name/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs           # åº“ libary crate çš„å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ main.rs          # äºŒè¿›åˆ¶ binary crate çš„å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ models.rs        # modelæ–‡ä»¶
â”œâ”€â”€ Cargo.toml
â””â”€â”€ Cargo.lock
```
- lib.rs æ–‡ä»¶
```rust
mod models;     //"mod åå­—" ä¸ models.rs æ–‡ä»¶å å¿…é¡»ä¸€è‡´
```
- models.rs æ–‡ä»¶
```rust 
mod models{ .. }
```

ã€3ã€‘åœ°å€æŸ¥æ‰¾  
<1> lib.rs ä¸­æ·»åŠ è¦å¼•ç”¨çš„ model åˆ—è¡¨ï¼ˆå¦‚ **mod models**ï¼‰  
<2> åœ¨ lib.rs åŒçº§åˆ«åˆ›å»ºæ–‡ä»¶å¤¹ï¼Œåå­—ä¸ **models** åŒå 
<3> åœ¨ model æ–‡ä»¶å¤¹å†…åˆ›å»º **mod.rs** æ–‡ä»¶ï¼Œå­˜æ”¾ model ä¿¡æ¯    

- é¡¹ç›®ç»“æ„  
```rust
project_name/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ models/          # åˆ—è¡¨åä¸ lib.rs ä¸­ä¸€è‡´
â”‚          â””â”€â”€ mod.rs    # å¿…é¡»æ˜¯æ­¤å‘½
â”‚   â”œâ”€â”€ lib.rs           # åº“ libary crate çš„å…¥å£æ–‡ä»¶ï¼šmod models;
â”‚   â”œâ”€â”€ main.rs          # äºŒè¿›åˆ¶ binary crate çš„å…¥å£æ–‡ä»¶
â”œâ”€â”€ Cargo.toml
â””â”€â”€ Cargo.lock
```
- lib.rs æ–‡ä»¶
```rust
mod models;     //"mod åå­—" ä¸ models.rs æ–‡ä»¶å å¿…é¡»ä¸€è‡´
```
#### 3ã€models æ¨¡å—çš„ å­æ¨¡å—  
ã€1ã€‘ **æ— è®ºæ˜¯ model è¿˜æ˜¯ å‡½æ•°ï¼Œé»˜è®¤éƒ½æ˜¯ç§æœ‰çš„ï¼Œæé«˜è®¿é—®æƒé™ï¼Œç”¨ pub ä¿®é¥°**    

<1> åœ¨ models.rs æ–‡ä»¶ä¸­æ·»åŠ  å­æ¨¡å— ï¼ˆå¦‚ï¼šmod enums;ï¼‰  
<2> åˆ›å»º models.rs åŒçº§åˆ«åŒåçš„ models æ–‡ä»¶å¤¹  
<3> åœ¨ models æ–‡ä»¶å¤¹ä¸­åˆ›å»º å­æ¨¡å—æ–‡ä»¶ï¼Œæ–‡ä»¶åä¸ models.rsä¸­å†™å…¥çš„å­æ¨¡å—æ–‡ä»¶åä¸€è‡´  

- é¡¹ç›®ç»“æ„
```rust
project_name/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ models/          # (2) åˆ›å»º çˆ¶æ¨¡å—åŒåçš„ models æ–‡ä»¶å¤¹
â”‚          â””â”€â”€ enums.rs  # (3) åˆ›å»º å­æ¨¡å—æ–‡ä»¶ï¼Œåå­—ä¸€è‡´
â”‚   â”œâ”€â”€ lib.rs           # åº“ libary crate çš„å…¥å£æ–‡ä»¶ï¼šmod models;
â”‚   â”œâ”€â”€ main.rs          # äºŒè¿›åˆ¶ binary crate çš„å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ models.rs        # (1) å†™å…¥å­æ¨¡å—ï¼Œ'mod å­æ¨¡å—æ–‡ä»¶å' (å¦‚ï¼šmod enums;)
â”œâ”€â”€ Cargo.toml
â””â”€â”€ Cargo.lock
```
ã€2ã€‘å­æ¨¡å— è°ƒç”¨(ç›¸å¯¹è·¯å¾„ã€ç»å¯¹è·¯å¾„)  
```rust
//main.rs æ–‡ä»¶ 
fn main(){
    //ç»å¯¹è·¯å¾„è°ƒç”¨ï¼š m1ä¸mainåŒç­‰çº§ï¼Œm2ã€method1()éœ€è¦pubä¿®é¥°æ‰å¯è®¿é—®
    crate::m1::m2::method1();
}

mod m1{                      //m1é»˜è®¤æ˜¯ç§æœ‰çš„ï¼Œä½†ä¸mainæ˜¯åŒç­‰çº§ï¼Œå¯ç›´æ¥è¢«è°ƒç”¨
    pub mod m2{              //m2æ˜¯m1å­æ¨¡å—ï¼Œé»˜è®¤ç§æœ‰
        pub fn method1(){    //method1()æ˜¯m1çš„æ–¹æ³•ï¼Œé»˜è®¤ç§æœ‰
            println!("Method1");
        }
    }
}

mod x1{
    fn method3(){
        //ç›¸å¯¹è·¯å¾„è°ƒç”¨ method2()
        //x2::method2() æˆ–å¦‚ä¸‹è°ƒç”¨
        self::x2::method2();
    }
    
    mod x2{
      pub fn method2(){
            println("Method2");

            //ç›¸å¯¹è·¯å¾„è°ƒç”¨ method1()
            super::super::m1::m2::method1();
        }
    }
}
```
ã€3ã€‘ main() åœ¨ binary crateä¸­ï¼Œè€Œ æ¨¡å— åœ¨libary crateä¸­
- é¡¹ç›®ç»“æ„
```rust
project_name/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ models/          # (2) åˆ›å»º çˆ¶æ¨¡å—åŒåçš„ models æ–‡ä»¶å¤¹
â”‚          â””â”€â”€ enums.rs  # (3) åˆ›å»º å­æ¨¡å—æ–‡ä»¶ï¼Œåå­—ä¸€è‡´
â”‚   â”œâ”€â”€ lib.rs           # åº“ libary crate çš„å…¥å£æ–‡ä»¶ï¼šmod models;
â”‚   â”œâ”€â”€ main.rs          # äºŒè¿›åˆ¶ binary crate çš„å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ models.rs        # (1) å†™å…¥å­æ¨¡å—ï¼Œ'mod å­æ¨¡å—æ–‡ä»¶å' (å¦‚ï¼šmod enums;)
â”œâ”€â”€ Cargo.toml
â””â”€â”€ Cargo.lock
```
- lib.rs ä½¿ç”¨ pub ä¿®é¥°
```rust
pub mod models;
```
- models.rs ä½¿ç”¨ pub ä¿®é¥° 
```rust
pub mod enums;
```
- enums.rs  
```rust
//æšä¸¾ç±»å‹ï¼Œpubä¿®é¥°
pub enum YesNo{
    Yes,
    No
}
```
- Cargo.toml é…ç½®æ–‡ä»¶
```rust
[package]
name = "package_name"    //package åå­—
version = "0.1.0"        //ç‰ˆæœ¬
edition = "2021"         //rustç‰ˆæœ¬ä¿¡æ¯

[dependencies]           //é¡¹ç›®ä¾èµ–
```
- main.rs ä¸­ä¸èƒ½ç›´æ¥è°ƒç”¨ lib.rs ä¸­å®šä¹‰çš„modelï¼Œå¯ä»¥é€šè¿‡ Cargo.toml ä¸­çš„ **package_name** æ¥å®ç°
```rust
// let y = crate:: ä¸èƒ½è°ƒç”¨æ•°æ®ï¼Œä½¿ç”¨ package_name
let y = package_name::models::enums::YesNo::Yes;
```
ã€3.1ã€‘å¤šç§æ¨¡å—è°ƒç”¨  
åªéœ€åœ¨ model.rs ä¸­å¼•å…¥æ¨¡å—åï¼Œåœ¨ models æ–‡ä»¶å¤¹åˆ›å»ºæ¨¡å—æ–‡ä»¶  
- é¡¹ç›®ç»“æ„
```rust
project_name/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ models/          # (2) åˆ›å»º çˆ¶æ¨¡å—åŒåçš„ models æ–‡ä»¶å¤¹
â”‚          â””â”€â”€ enums.rs  # (3) åˆ›å»º å­æ¨¡å—æ–‡ä»¶ï¼Œåå­—ä¸€è‡´
â”‚          â””â”€â”€ struts.rs  # (3) åˆ›å»º å­æ¨¡å—æ–‡ä»¶ï¼Œåå­—ä¸€è‡´
â”‚   â”œâ”€â”€ lib.rs           # åº“ libary crate çš„å…¥å£æ–‡ä»¶ï¼šmod models;
â”‚   â”œâ”€â”€ main.rs          # äºŒè¿›åˆ¶ binary crate çš„å…¥å£æ–‡ä»¶
â”‚   â”œâ”€â”€ models.rs        # (1) å†™å…¥å­æ¨¡å—ï¼Œ'mod å­æ¨¡å—æ–‡ä»¶å' (å¦‚ï¼šmod enums;)
â”œâ”€â”€ Cargo.toml
â””â”€â”€ Cargo.lock
```
- models.rsæ–‡ä»¶
```rust
pub mod enums;
pub mod structs;    //æ·»åŠ  struct æ¨¡å—
```  
- åœ¨ models æ–‡ä»¶å¤¹ä¸‹åˆ›å»º  structs.rs æ–‡ä»¶
ğŸ“: **æšä¸¾** æé«˜è®¿é—®æƒé™åªéœ€è¦åœ¨ ç±»å å‰åŠ  pub å³å¯  
    **ç»“æ„ä½“** å¿…é¡» ç±»åã€å±æ€§ éƒ½åŠ ä¸Š pub 
```rust
//å¼•å…¥ enums æ¨¡å—ä¸­çš„æšä¸¾æ•°æ®
use ctrate::model::enums::YesNo;

pub struct HousePrice{
    pub price: u32,
    pub area:String,
    pub bed_rooms: u32,
    pub main_road: YesNo
}  
```
- main.rs
```rust
use package_name::models::structs::HousePrice;

fn main(){
    let y = package_name::models::enums::YesNo::Yes;

    //é€šè¿‡ use å¼•å…¥ HousePrice
    let house_price = HousePrice{
        price: 1000,
        area: String::from("Center"),
        bed_rooms: 3,
        main_road: YesNo::Yes
    };
}
```
