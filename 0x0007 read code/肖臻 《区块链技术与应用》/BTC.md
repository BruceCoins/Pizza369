## 一、BTC 密码学原理  

- 【1】要求：     
  - Hash 不可篡改，数据一旦篡改，其Hash值也会改变  
  - Hash 函数计算过程是单向的  
  - puzzle friendly（难求正，已验证）  
 
- 【2】 实现：SHA-256(block header) <= target 

## 二、BTC 数据结构
### 【1】Hash 指针：  
   存放 指针地址 + 结构体的 Hash 值 	

**区块链中 Hash 指针：**    
- 后一个区块，保存前一个区块（包含上上个区块的Hash值）的 Hash 值，嵌套 hash 结构。

- 只要记录后边的Hash值，就能监测前面是否进行了篡改。

:waring: level DB (key, value) --->  (本区块hash值，内容)，内容中包含前一个区块的hash值
	
### 【2】Markle Tree  
  - 比特币中各个区块用Hash指针连接，每个区块中包含的交易，被组织成Markle Tree结构。  

  - 对每个交易进行Hash，然后对每两个Hash进行进一步Hash，最终得到一个根Hash。  
  
  - 每个区块分为两部分，block header和block body。 
  ```
  （1）block header：存放前一个区块头 的Hash值， 本区块的根Hash值，时间戳，难度值，Nonce值等。没有交易具体内容。 

  （2）block body：存放交易列表，多个交易被组织成Markle Tree结构。
  ```

### 【3】Markle proof   
- **轻节点只存放block header(区块头)，验证交易 是否在区块中：**  
```
  <1> 轻节点收到交易后，向全节点发送查询请求，要求提供该交易的Merkle路径。  
  
  <2> 根据交易Hash，与路径中提供的节点进行比较，判断交易是否在区块中。  
  
  <3> 即使交易在区块中，还要验证是否属于“最长有效链”。
```
  ![Markle proof](https://github.com/BruceCoins/Pizza369/blob/main/0x0007%20read%20code/%E8%82%96%E8%87%BB%20%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/images/Markle%20Tree.png)  

- **轻节点验证交易 不在区块中：sortedMerkleTree(排序的Merkle树)**   
```
<1> 对所有交易Hash，进行排序，并生成排序后的Merkle树。

<2> 轻节点收到交易后，根据交易Hash，在排序后的Merkle树中查找该交易Hash的索引。

<3> 如果不存在，找相邻的索引，并生成Merkle proof。计算根节点
```  
:warning: 比特币中没有 sortedMerkleTree   

## 三、BTC 协议   
### 【1】双花攻击  
- 指攻击者试图将同一笔比特币重复花费的行为（竞争攻击、芬尼攻击、51%攻击）  
- 解决机制：  
  - 工作量证明与最长链结合  
  - 交易确认机制  
  - 去中心化的节点验证  
 
每个交易包括输入输出两部分，比如 铸币 -> A， A -> B 转账 
```
输入：(1)要说明币的来源， (2)要说明 A 的公钥 （3）A的私钥签名

输出：(1)收款人 B 的公钥Hash
``` 
交易验证时，需要通过 ``A的公钥`` 与铸币时产生的 ``A的公钥Hash`` 进行验证。确保A的币来源正确。  

### 【2】BTC共识机制   
CAP 模型：一致性、可用性、分区容忍性（最多同时满足两个）  

POW 工作量证明、（出块奖励 + 交易费）  

## 四、BTC 实现  
### 基于交易模式（transaction-based ledger）--- BTC 
UTXO（unspent transaction output）还没有被花出去的交易的输出，简单理解为 账户余额  
- 每个元素给出 产生输出的交易Hash值、以及在交易中的索引位置，就可以定位到这个交易输出
```   
A 转给 B 100 BTC，转给 C 50 BTC；B 又转给 D 50 BTC
UTXO 只记录 B 剩余的 50 BTC 、C 的50 BTC、D 的50 BTC。

	A ----> B (100 BTC) ---> D (50 BTC)  
	   |  
	   |--> C (50 BTC)  
```  
工作 流程示例：
```
(1) 生成 UTXO：A 向 B 转账 0.5 BTC，交易创建两个输出：
	-> 输出 1：0.5 BTC 给 B（锁定到 B 的公钥）
	-> 输出 2：剩余资金（找零）返回给 A（锁定到 A 的公钥）。
	  这两个输出均为 UTXO，分别属于 B 和 A。
(2) 花费 UTXO：B 要向 C 转账 0.3 BTC 时，需引用上述 0.5 BTC 的 UTXO 作为输入，通过私钥签名解锁，然后生成新输出：
	-> 输出 1：0.3 BTC 给 C
	-> 输出 2：0.2 BTC 找零给 B。
	原 0.5 BTC 的 UTXO 被标记为 “已花费”，新生成的两个输出成为新的 UTXO。
```

### 基于账户模式 (account-based ledger) --- 以太坊  


## 五、BTC 网络原理   
所有节点地位同等，区块大小 1M 字节   

## 六、BTC 调整挖矿难度   
### 【1】目标阈值
SHA-256(block header) <= target   
目标阈值target 越小，挖矿难度越大   

### 【2】挖矿难度   
挖矿难度 与 目标阈值 成反比。阈值越小难度越大   

### 【3】为什么提高难度，维持出块10分钟    
应对算力变化，避免分叉，提高发动51%攻击难度，保持稳定  

### 【4】如何调整目标阈值,调整挖矿难度   
比特币规定每 2016 个区块调整一次目标阈值，大概14天  
```
目标阈值：		     actual time
target = target * -------------------
                    expected time

挖矿难度：			 					   expected time 
next_difficulty = previous_difficulty * -------------------
                                            actual time

actual time ：系统中产生最近 2016 个区块实际花费时间
expected time : 2016 * 10min (2016个区块预期花费时间 2周)
```
## 七、BTC 挖矿  

挖矿无记忆性：即什么时候挖矿成功的概率都相同

### 【1】全节点
```
● 一直在线
● 在本地硬盘上维护完整的区块链信息
● 在内存里维护UTXO集合，以便快速检验交易的正确性
● 监听比特币网络上的交易信息，验证每个交易的合法性
● 决定哪些交易会被打包到区块里
● 监听别的矿工挖出来的区块，验证其合法性（发布的区块是否符合难度要求、每两周调整挖矿难度、区块在最长有效链上）
● 挖矿:
	  决定沿着哪条链挖下去？（最长合法链）
	  当出现等长的分叉的时候，选择哪一个分叉？（最先听到的链）
```
### 【2】轻节点
```
● 不是一直在线  
● 不用保存整个区块链，只要保存每个区块的块头  
● 不用保存全部交易，只保存与自己相关的交易  
● 无法检验大多数交易的合法性，只能检验与自己相关的那些交易的合法性。  
● 无法检测网上发布的区块的正确性  
● 可以验证挖矿的难度  
● 只能检测哪个是最长链，不知道哪个是最长合法链
```
### 【3】BTC 保证安全性  
1> 密码学方面的保证，拥有私钥才能转账  
2> 共识机制   
### 【4】挖矿  
● CPU 挖矿 ---> GPU 挖矿 ---> ASIC 芯片挖矿  
● 个人挖矿  ---> 矿池（51%攻击、封杀他人账号）

## 八、BTC 交易类型  
### 【1】P2PKH（Pay-to-Public-Key-Hash，支付到公钥哈希）  
```
最基础、最常用的交易类型，约 90% 的比特币交易使用此类型。

1> 原理：接收方提供公钥哈希（通过私钥生成），发送方将资金锁定到这个哈希对应的地址（以 “1” 开头）。
2> 花费条件：需要提供与公钥哈希匹配的公钥和对应的私钥签名。
3> 脚本示例：
	  锁定脚本（输出）：OP_DUP OP_HASH160 <公钥哈希> OP_EQUALVERIFY OP_CHECKSIG
	  解锁脚本（输入）：<签名> <公钥>
```
### 【2】P2SH（Pay-to-Script-Hash，支付到脚本哈希）
```
为复杂交易设计，支持多签、时间锁定等功能，地址以 “3” 开头。

1> 原理：接收方先定义一个 “赎回脚本”（包含支付条件），再将脚本的哈希作为收款地址。发送方只需验证哈希，无需了解脚本内容。
2> 花费条件：需提供原始赎回脚本和满足脚本条件的签名 / 数据。
3> 典型应用：多签钱包（如 2-of-3 签名）、慈善捐赠、托管服务等。
4> 脚本示例：
	  锁定脚本：OP_HASH160 <脚本哈希> OP_EQUAL
 	  解锁脚本：<签名1> <签名2> <赎回脚本（如2-of-3多签脚本）>
```
### 【3】P2WPKH（Pay-to-Witness-Public-Key-Hash，隔离见证版 P2PKH）  
```
基于隔离见证（SegWit） 升级的交易类型，地址以 “bc1q” 开头（原生隔离见证地址）。

1> 改进：将签名数据（见证）从交易输入中分离，减少交易体积，降低手续费，同时修复交易延展性漏洞。
2> 原理：与 P2PKH 类似，但签名数据存储在单独的 “见证” 字段中，不影响交易 ID。
3> 脚本示例（隔离见证脚本）：0 <公钥哈希>
```
### 【4】P2WSH（Pay-to-Witness-Script-Hash，隔离见证版 P2SH）  
```
隔离见证版的 P2SH，支持更复杂的脚本，地址以 “bc1q” 开头（长地址形式）。

1> 优势：结合了 P2SH 的灵活性和 SegWit 的体积优势，适合需要复杂条件的大额交易。
2> 原理：赎回脚本的哈希被锁定，花费时需提供脚本和满足条件的见证数据。
```
### 【5】P2TR（Pay-to-Taproot，支付到 Taproot）
```
比特币Taproot 升级（2021 年） 后引入的新型交易类型，地址以 “bc1p” 开头。

1> 特点：
		(1)支持更复杂的智能合约逻辑（如多签、时间锁），但对外表现为普通交易，增强隐私性。
		(2)结合了 “密钥路径” 和 “脚本路径”，默认使用简单的密钥签名，复杂条件仅在需要时暴露。
		(3)进一步降低交易手续费，提升网络效率。
2> 应用：隐私性要求高的多签交易、复杂合约场景。
```
## 九、BTC 分叉  
### 【1】分叉原因   
- 挖矿同时产生区块，导致临时分叉(state fork)  
	- 分叉攻击  
 
- 协议升级导致分叉（protocd fork）  
	- 硬分叉  
    - 软分叉   

| 对比维度    |	硬分叉	                         | 软分叉                       |
|------------|-----------------------------------|------------------------------|
| 兼容性      |  不向前兼容（新旧规则冲突）	         | 向前兼容（新规则是旧规则子集）    |
| 链状态      |	分裂为两条独立链                    |	仅一条主链（无永久分裂）        |
| 节点升级要求 |	必须升级才能加入新链                |	不升级可继续运行（功能受限）     | 
| 规则变化幅度 |	重大变更（如区块大小、核心逻辑）      |	轻微调整（如新增验证条件）      |
| 安全性      |	若新链算力不足，可能面临 51% 攻击风险 |	安全性较稳定，依赖多数节点升级   |
| 典型应用场景 |	协议功能扩展、社区理念分歧           |	规则优化、漏洞修复、新增轻量特性  |

## 十、零知识证明  

### 【1】概念：
**零知识证明**：是指一方（证明者）向另一方（验证者）证明一个陈述是正确的，而无需透露除该陈述之外的任何信息。  
**同态隐藏**：是 **零知识证明** 的数学基础  
```
● 如果x、y不同，那么它们的加密函数值 E(x) 和 E(y) 也不相同。【-----> 不会出现碰撞】
● 给定 E(x) 的值，很难反推出 x 的值。 	【-----> 加密函数不可逆】
● 给定 E(x) 和 E(y) 的值，我们可以很容易的计算出某些关于 x，y 的加密函数值。
	 - 同态加法：通过 E(x) 和 E(y) 计算出 E(x+y) 的值   【 E(x)+E(y) = E(x+y) 】
	 - 同态乘法：通过 E(x) 和 E(y) 计算出 E(xy) 的值    【 E(x)E(y) = E(xy) 】
	 - 扩展到多项式
```
### 【2】举例1：   
Alice想要向Bob证明她知道一组数x和y使得x + y = 7, 同时不让Bob知道x和y的具体数值。
```
1> Alice 将加密后的值 E(x) 和 E(y) 的数值发送给 Bob；
2> Bob 利用收到的 E(x) 和 E(y)，通过同态加密的性质计算 E(x+y)（性质3，加法同态性）;
3> Bob 独立计算 E(7) 的值，如果 E(x+y) = E(7) ,那么验证通过，否则验证失败。
```
### 【3】举例2：盲签方法  
● 用户A提供SerialNum,银行在不知道SerialNum的情况下返回签名Token,减少A的存款
● 用户A把SerialNum和Token交给B完成交易
● 用户B拿SerialNum和Token给银行验证,银行验证通过,增加B的存款
● 银行无法把A和B联系起来。
● 中心化

### 【4】零币和零钞  
● 零币和零钞在协议层就融合了匿名化处理，其匿名属性来自密码学保证。   
● 零币(zerocoin)系统中存在基础币和零币，通过基础币和零币的来回转换，消除旧地址和新地址的关联性，其原理类似于混币服务。   
● 零钞(zerocash)系统使用zk-SNARKs协议，不依赖一种基础币，区块链中只记录交易的存在性和矿工用来验证系统正常运行所需要关键属性的证明。区块链上既不显示交易地址也不显示交易金额，所有交易通过零知识验证的方式进行。   
