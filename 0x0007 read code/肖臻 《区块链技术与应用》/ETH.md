## 一、ETH 概述
1. 缩短出块时间   
2. Proof of work（工作量证明） ---> Proof of stake（权益证明） 
3.智能合约  

## 二、ETH 账户  
基于账户的模型 ---> 重放攻击(解决：交易nonce计数器、链ID、签名包含唯一信息)  

外部账户：公钥、私钥钥对控制（包括：账户余额、nonce计数器）  
合约账户：不能发起交易，只能由外部账户发起交易。但是可以调用另外一个合约（包括：balance、nonce、代码code、相关状态storage）  

## 三、ETH 状态树  

(key,value)结构存储数据   

**key**： 账户地址：160位 十六进制显示40位    
**value**： 账户状态，包括账户余额、交易次数（nonce）、合约账户的代码哈希和存储根（storage root）等。这些信息会通过递归长度前缀编码（RLP）进行序列化后存储。序列化（RLP，只支持字节数组）    

### 【1】 trie（前缀树）数据结构  
```
     ( )
   /  |  \
  t   a   i
 / \       \
o    e      n
   / | \   /
  a  d  n  n 
```
上图是一棵 ``Trie`` 树，表示了关键字集合 ``{“a”, “to”, “tea”, “ted”, “ten”, “i”, “in”, “inn”} ``。  

- **Trie 树的基本特点：**
```
1. 每个节点的分支数目取决于这个 key 值里每个元素的取值范围（上例中 为26个字母+1个结束标志位 ，ETH地址是 0~f共16+1个结束标志位）  
2. Trei的查找效率取决于 Key 的长度，key 值越长，访问内存的次数越多（ETH地址长度40位十六进制）  
3. 不会出现 Hash 碰撞  
4. 只要输入不变，输入顺序不会影响 Trie 构成同一棵树  
5. ETH 账户通常只对有交易的部分账户进行更新，Trie 的局部更新很好  
```
- **Trie 树的基本性质：**  
```
1. 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。  
2. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。  
3. 每个节点的所有子节点包含的字符互不相同。  
```
通常在实现的时候，会在节点结构中设置一个标志，用来标记该结点处是否构成一个单词（关键字）。  

### 【2】Patricia Tree（压缩前缀树） --- Trie 升级版  
单词 abc、abf、adrf、siab 结构：
```
压缩前：                         压缩后：
        ( )                           ()
       /   \                         /  \
     a      s                      a    siab
    / \      \                    /  \
   b   d      i                  b    drf 
  / \   \      \                / \
 c   f   r      a              c   f
          \      \
           f      b
```
- **Patricia Tree 优点：**  
 树的高度降低，查询效率提高

- **缺点**
 添加新单词时，压缩的分支可能需要展开

### 【3】modify Merkle Patricia Tree(modify MPT)  ---- Trie 的二次升级   
![Modify MPT](https://github.com/BruceCoins/Pizza369/blob/main/0x0007%20read%20code/%E8%82%96%E8%87%BB%20%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/images/modify%20MPT.png)   
**1. Block Header (区块头):**  

区块头是区块链中每个区块的元数据部分，包含该区块的关键信息。  

**2. stateRoot (状态根):**  

是一个 Keccak 256 位的哈希值。它是状态树的根节点的哈希值，记录了所有交易执行和最终化后的状态。

**3. Keccak 256-bit hash:**  

一种加密哈希函数（KECCAK256()），用于生成固定长度的哈希值（256 位）。
图中的 stateRoot 就是通过这个函数计算得出的。

**4. World State Trie (世界状态树):**  

是一种树状数据结构，用于存储区块链中所有账户的状态。  
它由多种节点类型组成，包括扩展节点（Extension Node）、分支节点（Branch Node）和叶子节点（Leaf Node）。  

**5. World State Trie 的节点类型:**  

- Extension Node (扩展节点):  
用于共享公共前缀的节点。例如，根节点是一个扩展节点，**前缀**为 0，说明共享的 nibble（半字节）为偶数，即 a7。  
- Branch Node (分支节点):  
包含 16 个子节点（0-f）和一个可选的值。用于进一步分支到其他节点。  
- Leaf Node (叶子节点):  
存储最终的键值对。例如，prefix、key-end、value 表示叶子节点的前缀、键的结束部分和对应的值。  

**6. Prefixes (前缀):**  
```
用于区分节点类型的标识符：  
0：扩展节点（偶数个 nibble，即长度为偶数个）。  
1▢：扩展节点（奇数个 nibble，即长度为奇数个）。  
2：叶子节点（偶数个 nibble，即长度为偶数个）。  
3▢：叶子节点（奇数个 nibble，即长度为奇数个）。  
```
**7. Nibble (半字节):**  

4 位的数据单位（1 nibble = 4 bits = 1 十六进制数）。    

### 【4】ETH 链数据结构分析  
![](https://github.com/BruceCoins/Pizza369/blob/main/0x0007%20read%20code/%E8%82%96%E8%87%BB%20%E3%80%8A%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B/images/eth_chain.png)  
这张图展示了 **以太坊（Ethereum）区块链中两个连续区块（Block N 和 Block N+1）的数据结构**，涵盖了区块头、默克尔树（Merkle Tree）和默克尔-帕特里夏状态树（Merkle-Patricia State Trie）等核心组件。以下是详细分析：  
- **Block Header（区块头）：**  
区块头是区块的元数据部分，包含以下字段（图中列出的关键字段）：
```
     Prev Hash： 前一个区块（头）的哈希值，用于维护链式结构。  
     Nonce： 工作量证明（PoW）中使用的随机数（以太坊已转向 PoS，但图中显示的是旧版 PoW 设计）。  
     Timestamp： 区块生成的时间戳。  
     Uncles Hash： 叔块（Uncle Blocks）列表的哈希值，用于奖励早期废弃区块的矿工。  
     Beneficiary： 矿工或验证者的地址，接收区块奖励和手续费。  
     Logs Bloom： 日志的布隆过滤器，用于高效检索智能合约事件。  
     Difficulty： 当前区块的挖矿难度（PoW 机制下）。  
     Extra Data ：可选字段，可存储任意数据。  
     Block Num： 区块高度（如 Block N、Block N+1）。  
     Gas Limit： 区块允许的最大 Gas 总量。  
     Gas Used： 区块中交易实际消耗的 Gas。  
     Mix Hash： PoW 的混合哈希，用于验证工作量。  
     State Root： 世界状态树（State Trie）的根哈希，反映所有账户的最新状态。  
     Transaction Root： 交易默克尔树的根哈希。  
     Receipt Root： 交易收据默克尔树的根哈希。  
```
- **State Trie 状态树**
```
     Nonce：账户发送的交易数量（或合约创建次数）。  
     Balance：账户的以太币余额。  
     CodeHash：合约代码的哈希值（外部账户为 keccak256("")）。  
     StorageRoot：合约存储数据的默克尔-帕特里夏树的根哈希（仅合约账户有）
```
## 四、交易树和收据树  
```
- 交易树 和 收据树 在节点关系上 一一对应。  
- 数据结构：都是 MPT （状态树查找的key值是账户地址、交易树和收据树查找的key值是其在发布的区块排名第几）。  
- 交易的排列顺序是由发布区块的解点决定的。
- 交易树 证明交易被打包到某个区块中的Mekle prool， 收据树提供执行结果的Merkle Prool
```
### 【1】交易树、收据树 与 状态树 区别  
```
1. 交易树、收据树：都只是把当前发布的区块里的交易组织起来，  
   状态树：是把系统中所有的账户状态都要包含进去，与当前交易无关。  

2. 交易树、收据树：每个区块独立生成，不共享节点。   
   状态树：与之前的状态树共享节点，只对有变更的节点重新生成分支  
```
### 【2】Bloom Filter 数据结构  
- **介绍：**  
Bloom Filter（布隆过滤器）是一种空间效率极高的概率型数据结构，用于快速判断一个元素是否 “可能存在” 于某个很大的集合中，或 “一定不存在” 于集合中。  

- **组成：**  
  一个固定大小的二进制数组（初始值全为 0 ）、多个独立的哈希函数（通常为 K 个）  

- **特性：**  
```
  1. 空间效率极高：只需存储二进制位，无需存储元素本身，适合存储大规模数据集。  
  2. 查询速度快：插入、查询操作均为 O(K) (K 为哈希函数数量，通常为常数)，时间效率接近 O(1)。  
  3. 存在“假阳性”：可能将 “不存在的元素” 误判为 “存在”(哈希碰撞导致)，但绝不会出现 “假阴性” 即 “存在的元素” 一定能被正确识别。  
  4. 不支持删除操作
```
- **参数设计与误判率：**
```
  1. 数组长度（m）：越长，误判率越低（但空间占用增加）。
  2. 哈希函数数量（K）：过少会导致碰撞增多，过多会使数组过早被填满，需根据 m 和 元素总数 n 平衡（最优 K 数量 ≈ (m/n) * ln2）。
  3. 元素总数（n）：n 越大，误判率越高。
```

- **公式估算误判率：**
P ≈ (1 - e^(-kn / m))^k   (当 k = (m/n) * ln2 时，P 可最小化)   

### 【3】ETH 中的 Bloom Filter  
- **应用：**   
```
每个交易执行后生成一个收据，收据中包含一个 Bloom Filter 来记录这个交易类型、地址等信息。

发布的区块在 block header 也有一个总的 Bloom Filter，是区块中所有交易的 Bloom Filter 的 并集
```
  
- **案例：**
```
查过去十天的跟某智能合约相关的所有交易：  
1. 先在 block header 中 Bloom Filter 又要查找的类型；    
2. 如果没有，那就不是要找的区块；  
3. 如果有，再去查找收据树中对应的Bloom Filter，找到相关交易进行确认。
```
## 五、GHOST 协议  

以太坊的 GHOST 协议，全称为 Greedy Heaviest Observed SubTree protocol，即贪婪最重观察子树协议，它是 Nakamoto 共识的一个延伸，主要用于解决以太坊中的临时性分叉问题，提高系统吞吐量，降低反应时间。以下是对 GHOST 协议的详细介绍：

**叔块的概念：** 叔块是那些虽然合法，但没有成为主链一部分的区块。在以太坊中，由于出块时间较短，可能会出现多个节点同时挖出区块的情况，从而导致分叉，这些分叉区块中没有成为主链的部分就成为了叔块。
主链选择规则：不同于比特币的最长链规则，GHOST 协议选择主链时，会将分叉区块也考虑进去，选择包含了最多区块（包括叔块）的链作为最长链，即 “最重的链”。
**叔块奖励机制：** 以太坊中，7 代内的叔块都能够获得奖励，奖励比例与叔块和主链上下一次出块的区块的代数有关，代数越近，奖励越高。具体奖励比例为 7/8、6/8、5/8、4/8、3/8、2/8、1/8，奖励 = 奖励比例出块奖励。例如，若出块奖励为 3ETH，某叔块与主链上下一次出块的区块代数相差为 1，则该叔块的矿工可获得 3ETH7/8 的奖励。
**引用叔块的奖励：** 当前区块每包含 1 个叔块，会额外获得 1/32 的出块奖励，每次出块最多可包含 2 个叔块。比如，出块奖励为 3ETH，若一个区块包含了 2 个叔块，则该区块的矿工除了获得基础出块奖励外，还能额外获得 3ETH1/322 的奖励。
**协议的作用：** GHOST 协议让以太坊在 PoW 阶段比比特币更具公平性与抗分叉性，它保证了网络的去中心化，让延迟较高的矿工也有奖励，同时减少了算力浪费，鼓励矿工集中算力、追求同步优势，使得区块链在出现分叉后能够快速合并。









